"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5097],{10139:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"type-safety","title":"Type Safety","description":"e2en is built with strict Luau types. This guide explains how to get full intellisense and type checking in your project.","source":"@site/docs/type-safety.md","sourceDirName":".","slug":"/type-safety","permalink":"/e2en/docs/type-safety","draft":false,"unlisted":false,"editUrl":"https://github.com/estrogenie/e2en/edit/master/docs/type-safety.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"defaultSidebar","previous":{"title":"Middleware","permalink":"/e2en/docs/middleware"}}');var i=r(74848),a=r(28453);const l={sidebar_position:10},s="Type Safety",o={},c=[{value:"The <code>:: any</code> Pattern",id:"the--any-pattern",level:2},{value:"Why is this necessary?",id:"why-is-this-necessary",level:3},{value:"Setting Up Types",id:"setting-up-types",level:2},{value:"Server Code",id:"server-code",level:3},{value:"Client Code",id:"client-code",level:3},{value:"Available Types",id:"available-types",level:2},{value:"Type Checking Commands",id:"type-checking-commands",level:2},{value:"Strict Mode",id:"strict-mode",level:2},{value:"Validating Client Input",id:"validating-client-input",level:2},{value:"Type Narrowing",id:"type-narrowing",level:3},{value:"Generic Services",id:"generic-services",level:2},{value:"Typed Remote Properties",id:"typed-remote-properties",level:2},{value:"Typed Signals",id:"typed-signals",level:2},{value:"Common Type Patterns",id:"common-type-patterns",level:2},{value:"Optional Values",id:"optional-values",level:3},{value:"Callbacks with Trove",id:"callbacks-with-trove",level:3},{value:"Type Assertions",id:"type-assertions",level:3},{value:"Excluded from Strict Checking",id:"excluded-from-strict-checking",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"type-safety",children:"Type Safety"})}),"\n",(0,i.jsx)(n.p,{children:"e2en is built with strict Luau types. This guide explains how to get full intellisense and type checking in your project."}),"\n",(0,i.jsxs)(n.h2,{id:"the--any-pattern",children:["The ",(0,i.jsx)(n.code,{children:":: any"})," Pattern"]}),"\n",(0,i.jsx)(n.p,{children:"You'll see this pattern throughout e2en code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local e2en: Types.e2enServer = require(root) :: any\n"})}),"\n",(0,i.jsx)(n.h3,{id:"why-is-this-necessary",children:"Why is this necessary?"}),"\n",(0,i.jsx)(n.p,{children:"The framework returns different modules depending on runtime context:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Inside init.luau\nif IS_SERVER then\n    return serverModule  -- Has CreateService, GetService, etc.\nelse\n    return clientModule  -- Has CreateController, GetController, etc.\nend\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Luau tries to unify both return types at analysis time, which causes type errors. The ",(0,i.jsx)(n.code,{children:":: any"})," cast bypasses this, and the explicit type annotation (",(0,i.jsx)(n.code,{children:"e2en: Types.e2enServer"}),") provides the correct type information."]}),"\n",(0,i.jsx)(n.h2,{id:"setting-up-types",children:"Setting Up Types"}),"\n",(0,i.jsx)(n.h3,{id:"server-code",children:"Server Code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local root = script.Parent.Parent.Parent\nlocal Types = require(root.Types)\n\nlocal e2en: Types.e2enServer = require(root) :: any\n"})}),"\n",(0,i.jsx)(n.h3,{id:"client-code",children:"Client Code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local root = script.Parent.Parent.Parent\nlocal Types = require(root.Types)\n\nlocal e2en: Types.e2enClient = require(root) :: any\n"})}),"\n",(0,i.jsx)(n.h2,{id:"available-types",children:"Available Types"}),"\n",(0,i.jsx)(n.p,{children:"Import types from the Types module:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local Types = require(root.Types)\n\n-- Core types\nexport type Service = Types.Service\nexport type Controller = Types.Controller\nexport type ServiceDefinition = Types.ServiceDefinition\nexport type ControllerDefinition = Types.ControllerDefinition\n\n-- Communication types\nexport type RemoteSignal<T...> = Types.RemoteSignal<T...>\nexport type RemoteProperty<T> = Types.RemoteProperty<T>\nexport type ClientRemoteSignal<T...> = Types.ClientRemoteSignal<T...>\nexport type ClientRemoteProperty<T> = Types.ClientRemoteProperty<T>\n\n-- Utility types\nexport type Trove = Types.Trove\nexport type Signal<T...> = Types.Signal<T...>\nexport type Connection = Types.Connection\n"})}),"\n",(0,i.jsx)(n.h2,{id:"type-checking-commands",children:"Type Checking Commands"}),"\n",(0,i.jsxs)(n.p,{children:["Run type checking after every ",(0,i.jsx)(n.code,{children:".luau"})," change:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'luau-lsp analyze \\\n  --sourcemap=sourcemap.json \\\n  --defs=.luau-types/globalTypes.d.luau \\\n  --flag:LuauSolverV2=false \\\n  --ignore="**/Libraries/**" \\\n  --ignore="**/Iris/**" \\\n  e2en/src src\n'})}),"\n",(0,i.jsx)(n.p,{children:"Generate the sourcemap first:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"rojo sourcemap default.project.json --output sourcemap.json\n"})}),"\n",(0,i.jsx)(n.h2,{id:"strict-mode",children:"Strict Mode"}),"\n",(0,i.jsxs)(n.p,{children:["e2en uses strict mode via ",(0,i.jsx)(n.code,{children:".luaurc"}),", not ",(0,i.jsx)(n.code,{children:"--!strict"})," comments. Your ",(0,i.jsx)(n.code,{children:".luaurc"})," should include:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "languageMode": "strict"\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"validating-client-input",children:"Validating Client Input"}),"\n",(0,i.jsxs)(n.p,{children:["When handling client input, use ",(0,i.jsx)(n.code,{children:"any"})," (not ",(0,i.jsx)(n.code,{children:"unknown"}),") and validate:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function MyService.Client:DoSomething(player: Player, value: any): boolean\n    -- Validate type\n    if typeof(value) ~= "string" then\n        return false\n    end\n\n    -- Now value is narrowed to string\n    return self.Server:ProcessString(player, value)\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"type-narrowing",children:"Type Narrowing"}),"\n",(0,i.jsx)(n.p,{children:"Use guard clauses for type narrowing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Good: Guard clause narrows type\nfunction process(data: any)\n    if typeof(data) ~= "table" then\n        return\n    end\n    -- data is now table\n\n    if typeof(data.name) ~= "string" then\n        return\n    end\n    -- data.name is now string\nend\n\n-- Avoid: Conditional access doesn\'t narrow\nfunction process(data: any)\n    if data and data.name then\n        -- data.name is still any\n    end\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"generic-services",children:"Generic Services"}),"\n",(0,i.jsx)(n.p,{children:"Type your custom service methods:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local InventoryService = e2en.CreateService({\n    Name = "InventoryService",\n    Client = {},\n\n    _items = {} :: { [Player]: { string } },\n})\n\nfunction InventoryService:GetItems(player: Player): { string }\n    return self._items[player] or {}\nend\n\nfunction InventoryService:AddItem(player: Player, itemId: string): boolean\n    local items = self._items[player]\n    if not items then\n        items = {}\n        self._items[player] = items\n    end\n    table.insert(items, itemId)\n    return true\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"typed-remote-properties",children:"Typed Remote Properties"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'type PlayerData = {\n    coins: number,\n    level: number,\n    inventory: { string },\n}\n\nlocal DataService = e2en.CreateService({\n    Name = "DataService",\n    Client = {\n        PlayerData = e2en.CreateProperty({} :: PlayerData),\n    },\n})\n\n-- Type is inferred\nself.Client.PlayerData:SetFor(player, {\n    coins = 100,\n    level = 1,\n    inventory = {},\n})\n'})}),"\n",(0,i.jsx)(n.h2,{id:"typed-signals",children:"Typed Signals"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'type DamageEvent = {\n    amount: number,\n    source: string,\n    critical: boolean,\n}\n\nlocal CombatService = e2en.CreateService({\n    Name = "CombatService",\n    Client = {\n        DamageDealt = e2en.CreateSignal(), -- RemoteSignal<DamageEvent>\n    },\n})\n\n-- Fire with typed data\nself.Client.DamageDealt:Fire(player, {\n    amount = 25,\n    source = "Enemy",\n    critical = false,\n} :: DamageEvent)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"common-type-patterns",children:"Common Type Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"optional-values",children:"Optional Values"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'function findPlayer(name: string): Player?\n    for _, player in Players:GetPlayers() do\n        if player.Name == name then\n            return player\n        end\n    end\n    return nil\nend\n\nlocal player = findPlayer("Bob")\nif player then\n    -- player is Player (not Player?)\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"callbacks-with-trove",children:"Callbacks with Trove"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'e2en.OnCharacterAdded(function(player: Player, character: Model, trove: Trove)\n    local humanoid = character:WaitForChild("Humanoid") :: Humanoid\n\n    trove:Connect(humanoid.Died, function()\n        -- Type-safe callback\n    end)\nend)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"type-assertions",children:"Type Assertions"}),"\n",(0,i.jsx)(n.p,{children:"When you know more than the type system:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local part = workspace:FindFirstChild("SpawnPoint")\nassert(part, "SpawnPoint not found")\n\n-- part is Instance, but we know it\'s a Part\nlocal spawnPart = part :: Part\nprint(spawnPart.Position)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"excluded-from-strict-checking",children:"Excluded from Strict Checking"}),"\n",(0,i.jsx)(n.p,{children:"Some folders are excluded from strict type checking:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Libraries/"})," - Third-party code"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Iris/"})," - UI library"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ShapecastHitbox/"})," - External module"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ClientLoader.client.luau"})," - Bootstrap script"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Configure exclusions in your type check command with ",(0,i.jsx)(n.code,{children:"--ignore"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>s});var t=r(96540);const i={},a=t.createContext(i);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);