{"searchDocs":[{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"/e2en/api/ClientRemoteProperty","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteProperty","url":"/e2en/api/ClientRemoteProperty#functions","content":" ","version":null,"tagName":"h2"},{"title":"Get​","type":1,"pageTitle":"ClientRemoteProperty","url":"/e2en/api/ClientRemoteProperty#Get","content":"&lt;/&gt; ClientRemoteProperty.Get(self: ClientRemotePropertyInternal&lt;T&gt;) → T-- The current value Gets the current value.  ","version":null,"tagName":"h3"},{"title":"IsReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/e2en/api/ClientRemoteProperty#IsReady","content":"&lt;/&gt; ClientRemoteProperty.IsReady(self: ClientRemotePropertyInternal&lt;T&gt;) → boolean-- True if ready Checks if the initial value has been received.  ","version":null,"tagName":"h3"},{"title":"OnReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/e2en/api/ClientRemoteProperty#OnReady","content":"&lt;/&gt; ClientRemoteProperty.OnReady( self: ClientRemotePropertyInternal&lt;T&gt;, timeout: number?-- Optional timeout in seconds ) → T?-- The value, or nil if timed out Yields until the initial value is received. Returns nil if the timeout is reached before the value arrives.  ","version":null,"tagName":"h3"},{"title":"Observe​","type":1,"pageTitle":"ClientRemoteProperty","url":"/e2en/api/ClientRemoteProperty#Observe","content":"&lt;/&gt; ClientRemoteProperty.Observe( self: ClientRemotePropertyInternal&lt;T&gt;, callback: (value: T) → ()-- The callback function ) → Connection-- The connection Observes changes to the property value. The callback fires immediately with the current value (if ready), then on each subsequent change.  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"/e2en/api/ClientRemoteProperty#Destroy","content":"&lt;/&gt; ClientRemoteProperty.Destroy(self: ClientRemotePropertyInternal&lt;T&gt;) → () Destroys the property and its internal signal. ","version":null,"tagName":"h3"},{"title":"Component","type":0,"sectionRef":"#","url":"/e2en/api/Component","content":"","keywords":"","version":null},{"title":"e2en","type":0,"sectionRef":"#","url":"/e2en/api/e2en","content":"e2en e2en is a system-based Roblox framework with automatic client replication. The framework provides different APIs depending on context: Server: Use e2enServer for creating services Client: Use e2enClient for creating controllers -- Server local e2en: Types.e2enServer = require(path.to.e2en) :: any e2en.Run() -- Client (automatically started) local e2en: Types.e2enClient = require(path.to.e2en) :: any ","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Component","url":"/e2en/api/Component#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Component","url":"/e2en/api/Component#new","content":"&lt;/&gt; Component.new( config: ComponentConfig-- Configuration with Tag and optional Ancestors ) → Component-- The component class Creates a new component class.  ","version":null,"tagName":"h3"},{"title":"Start​","type":1,"pageTitle":"Component","url":"/e2en/api/Component#Start","content":"&lt;/&gt; Component.Start(self: ComponentClassInternal&lt;T&gt;) → () Starts tracking tagged instances. Call this after defining the prototype to begin creating component instances for tagged objects.  ","version":null,"tagName":"h3"},{"title":"GetAll​","type":1,"pageTitle":"Component","url":"/e2en/api/Component#GetAll","content":"&lt;/&gt; Component.GetAll(self: ComponentClassInternal&lt;T&gt;) → {ComponentInstance}-- Array of active instances Gets all active component instances.  ","version":null,"tagName":"h3"},{"title":"FromInstance​","type":1,"pageTitle":"Component","url":"/e2en/api/Component#FromInstance","content":"&lt;/&gt; Component.FromInstance( self: ComponentClassInternal&lt;T&gt;, instance: Instance -- The tagged instance ) → ComponentInstance?-- The component, or nil if not found Gets the component instance for a tagged Instance.  ","version":null,"tagName":"h3"},{"title":"WaitForInstance​","type":1,"pageTitle":"Component","url":"/e2en/api/Component#WaitForInstance","content":"&lt;/&gt; Component.WaitForInstance( self: ComponentClassInternal&lt;T&gt;, instance: Instance ,-- The instance to wait for timeout: number?-- Optional timeout (default 10 seconds) ) → ComponentInstance?-- The component, or nil if timed out Waits for a component instance on a tagged Instance.  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Component","url":"/e2en/api/Component#Destroy","content":"&lt;/&gt; Component.Destroy(self: ComponentClassInternal&lt;T&gt;) → () Stops tracking and destroys all component instances. ","version":null,"tagName":"h3"},{"title":"Client","type":0,"sectionRef":"#","url":"/e2en/api/Client","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#functions","content":" ","version":null,"tagName":"h2"},{"title":"CreateController​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#CreateController","content":"&lt;/&gt; Client.CreateController( definition: ControllerDefinition-- The controller definition table ) → Controller -- The created controller Creates a new controller. Controllers are client-side singletons that handle local game logic and UI. local MyController = e2en.CreateController({ Name = &quot;MyController&quot;, }) function MyController:Init() print(&quot;Initializing&quot;) end function MyController:Start() print(&quot;Starting&quot;) end   ","version":null,"tagName":"h3"},{"title":"GetController​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#GetController","content":"&lt;/&gt; Client.GetController( controllerName: string-- The name of the controller ) → Controller -- The controller instance Gets a controller by name. Can only be called after the framework has started. local UIController = e2en.GetController(&quot;UIController&quot;)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Client","url":"/e2en/api/Client##","content":"Type\tDescription&quot;Controller not found&quot;\tIf no controller with the given name exists  ","version":null,"tagName":"h3"},{"title":"GetControllers​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#GetControllers","content":"&lt;/&gt; Client.GetControllers() → {[string]: Controller }-- Dictionary of controller name to instance Gets all registered controllers.  ","version":null,"tagName":"h3"},{"title":"AddControllers​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#AddControllers","content":"&lt;/&gt; Client.AddControllers( parent: Instance -- Parent container to search ) → {Controller }-- Array of loaded controllers Loads controllers from direct children ModuleScripts.  ","version":null,"tagName":"h3"},{"title":"AddControllersDeep​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#AddControllersDeep","content":"&lt;/&gt; Client.AddControllersDeep( parent: Instance -- Parent container to search ) → {Controller }-- Array of loaded controllers Loads controllers from all descendant ModuleScripts.  ","version":null,"tagName":"h3"},{"title":"AddSystems​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#AddSystems","content":"&lt;/&gt; Client.AddSystems( parent: Instance -- Parent container with system folders ) → {Controller }-- Array of loaded controllers Loads controllers from Controller.luau files in direct child folders.  ","version":null,"tagName":"h3"},{"title":"AddSystemsDeep​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#AddSystemsDeep","content":"&lt;/&gt; Client.AddSystemsDeep( parent: Instance -- Parent container to search recursively ) → {Controller }-- Array of loaded controllers Loads controllers from Controller.luau files in all descendant folders.  ","version":null,"tagName":"h3"},{"title":"GetService​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#GetService","content":"&lt;/&gt; Client.GetService( serviceName: string-- The name of the service ) → ServiceProxy-- Proxy to the service's Client table Gets a proxy to a server service. The proxy provides access to the service's Client table: signals, properties, and methods. local ShopService = e2en.GetService(&quot;ShopService&quot;) -- Call methods local items = ShopService:GetItems() -- Listen to signals ShopService.ItemAdded:Connect(function(item) print(&quot;Got item:&quot;, item) end) -- Observe properties ShopService.Coins:Observe(function(coins) print(&quot;Coins:&quot;, coins) end)   ","version":null,"tagName":"h3"},{"title":"OnCharacterAdded​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#OnCharacterAdded","content":"&lt;/&gt; Client.OnCharacterAdded( callback: ( character: Model , trove: Trove ) → ()-- The callback function ) → () Registers a callback for when the local player's character spawns. The callback fires immediately if a character already exists. The trove auto-cleans when the character is removed. e2en.OnCharacterAdded(function(character, trove) local humanoid = character:WaitForChild(&quot;Humanoid&quot;) trove:Connect(humanoid.Died, function() print(&quot;Died&quot;) end) end)   ","version":null,"tagName":"h3"},{"title":"OnCharacterRemoving​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#OnCharacterRemoving","content":"&lt;/&gt; Client.OnCharacterRemoving( callback: (character: Model ) → ()-- The callback function ) → () Registers a callback for when the local player's character is removed. e2en.OnCharacterRemoving(function(character) print(&quot;Character removing&quot;) end)   ","version":null,"tagName":"h3"},{"title":"GetCharacterTrove​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#GetCharacterTrove","content":"&lt;/&gt; Client.GetCharacterTrove() → Trove?-- The character's trove, or nil Gets the trove associated with the current character. Returns nil if no character exists.  ","version":null,"tagName":"h3"},{"title":"GetCharacter​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#GetCharacter","content":"&lt;/&gt; Client.GetCharacter() → Model? -- The character, or nil Gets the local player's current character. Returns nil if no character exists.  ","version":null,"tagName":"h3"},{"title":"Start​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#Start","content":"&lt;/&gt; Client.Start() → () Starts the client framework. This is called automatically by the ClientLoader script. Most users don't need to call this directly.  ","version":null,"tagName":"h3"},{"title":"OnStart​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#OnStart","content":"&lt;/&gt; Client.OnStart() → () Yields until the framework has finished starting. e2en.OnStart() print(&quot;Framework is ready!&quot;)   ","version":null,"tagName":"h3"},{"title":"IsStarted​","type":1,"pageTitle":"Client","url":"/e2en/api/Client#IsStarted","content":"&lt;/&gt; Client.IsStarted() → boolean-- True if the framework has started Checks if the framework has finished starting. ","version":null,"tagName":"h3"},{"title":"e2enServer","type":0,"sectionRef":"#","url":"/e2en/api/e2enServer","content":"e2enServer This item only works when running on the server. Server Server-side framework API for creating and managing services. Access via requiring e2en on the server: local e2en: Types.e2enServer = require(ServerScriptService.e2en) :: any ","keywords":"","version":null},{"title":"e2enClient","type":0,"sectionRef":"#","url":"/e2en/api/e2enClient","content":"e2enClient This item only works when running on the client. Client Client-side framework API for creating and managing controllers. Access via requiring e2en on the client: local e2en: Types.e2enClient = require(ReplicatedStorage.e2en) :: any ","keywords":"","version":null},{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"/e2en/api/ClientRemoteSignal","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteSignal","url":"/e2en/api/ClientRemoteSignal#functions","content":" ","version":null,"tagName":"h2"},{"title":"Fire​","type":1,"pageTitle":"ClientRemoteSignal","url":"/e2en/api/ClientRemoteSignal#Fire","content":"&lt;/&gt; ClientRemoteSignal.Fire( self: ClientRemoteSignal&lt;T...&gt;, ...: T...-- Data to send ) → () Fires the signal to the server.  ","version":null,"tagName":"h3"},{"title":"Connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"/e2en/api/ClientRemoteSignal#Connect","content":"&lt;/&gt; ClientRemoteSignal.Connect( self: ClientRemoteSignal&lt;T...&gt;, callback: (T...) → ()-- The callback function ) → Connection-- The connection Connects a callback to listen for server fires. ","version":null,"tagName":"h3"},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"/e2en/api/RemoteSignal","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"/e2en/api/RemoteSignal#functions","content":" ","version":null,"tagName":"h2"},{"title":"Fire​","type":1,"pageTitle":"RemoteSignal","url":"/e2en/api/RemoteSignal#Fire","content":"&lt;/&gt; RemoteSignal.Fire( self: RemoteSignal&lt;T...&gt;, player: Player ,-- The target player ...: T...-- Data to send ) → () Fires the signal to a specific player.  ","version":null,"tagName":"h3"},{"title":"FireAll​","type":1,"pageTitle":"RemoteSignal","url":"/e2en/api/RemoteSignal#FireAll","content":"&lt;/&gt; RemoteSignal.FireAll( self: RemoteSignal&lt;T...&gt;, ...: T...-- Data to send ) → () Fires the signal to all players.  ","version":null,"tagName":"h3"},{"title":"FireFor​","type":1,"pageTitle":"RemoteSignal","url":"/e2en/api/RemoteSignal#FireFor","content":"&lt;/&gt; RemoteSignal.FireFor( self: RemoteSignal&lt;T...&gt;, players: {Player },-- The target players ...: T...-- Data to send ) → () Fires the signal to a list of players.  ","version":null,"tagName":"h3"},{"title":"FireExcept​","type":1,"pageTitle":"RemoteSignal","url":"/e2en/api/RemoteSignal#FireExcept","content":"&lt;/&gt; RemoteSignal.FireExcept( self: RemoteSignal&lt;T...&gt;, exceptPlayer: Player ,-- The player to exclude ...: T...-- Data to send ) → () Fires the signal to all players except one.  ","version":null,"tagName":"h3"},{"title":"FireFilter​","type":1,"pageTitle":"RemoteSignal","url":"/e2en/api/RemoteSignal#FireFilter","content":"&lt;/&gt; RemoteSignal.FireFilter( self: RemoteSignal&lt;T...&gt;, predicate: ( Player , T... ) → boolean,-- Filter function ...: T...-- Data to send ) → () Fires the signal to players matching a predicate. self.Client.TeamUpdate:FireFilter(function(player) return player.Team == Teams.Red end, data)   ","version":null,"tagName":"h3"},{"title":"Connect​","type":1,"pageTitle":"RemoteSignal","url":"/e2en/api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal.Connect( self: RemoteSignal&lt;T...&gt;, callback: ( player: Player , T... ) → ()-- The callback function ) → Connection-- The connection Connects a callback to listen for client fires. self.Client.AttackRequest:Connect(function(player, target) handleAttack(player, target) end)   ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"RemoteSignal","url":"/e2en/api/RemoteSignal#Destroy","content":"&lt;/&gt; RemoteSignal.Destroy(self: RemoteSignal&lt;T...&gt;) → () Destroys the signal and its underlying RemoteEvent. ","version":null,"tagName":"h3"},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"/e2en/api/RemoteProperty","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#functions","content":" ","version":null,"tagName":"h2"},{"title":"Get​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#Get","content":"&lt;/&gt; RemoteProperty.Get(self: RemotePropertyInternal&lt;T&gt;) → T-- The top value Gets the top value of the property.  ","version":null,"tagName":"h3"},{"title":"Set​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#Set","content":"&lt;/&gt; RemoteProperty.Set( self: RemotePropertyInternal&lt;T&gt;, value: T-- The new value ) → () Sets the value for all players and clears per-player overrides.  ","version":null,"tagName":"h3"},{"title":"SetTop​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#SetTop","content":"&lt;/&gt; RemoteProperty.SetTop( self: RemotePropertyInternal&lt;T&gt;, value: T-- The new top value ) → () Sets the top value without clearing per-player overrides. Players with overrides keep their override; others get the new value.  ","version":null,"tagName":"h3"},{"title":"SetFor​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#SetFor","content":"&lt;/&gt; RemoteProperty.SetFor( self: RemotePropertyInternal&lt;T&gt;, player: Player ,-- The target player value: T-- The value for this player ) → () Sets a per-player override value.  ","version":null,"tagName":"h3"},{"title":"SetForList​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#SetForList","content":"&lt;/&gt; RemoteProperty.SetForList( self: RemotePropertyInternal&lt;T&gt;, players: {Player },-- The target players value: T-- The value for these players ) → () Sets a per-player override for multiple players.  ","version":null,"tagName":"h3"},{"title":"SetFilter​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#SetFilter","content":"&lt;/&gt; RemoteProperty.SetFilter( self: RemotePropertyInternal&lt;T&gt;, predicate: (Player ) → boolean,-- Filter function value: T-- The value for matching players ) → () Sets a per-player override for players matching a predicate.  ","version":null,"tagName":"h3"},{"title":"ClearFor​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#ClearFor","content":"&lt;/&gt; RemoteProperty.ClearFor( self: RemotePropertyInternal&lt;T&gt;, player: Player -- The player to clear ) → () Clears a player's override, reverting them to the top value.  ","version":null,"tagName":"h3"},{"title":"ClearForList​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#ClearForList","content":"&lt;/&gt; RemoteProperty.ClearForList( self: RemotePropertyInternal&lt;T&gt;, players: {Player }-- The players to clear ) → () Clears overrides for multiple players.  ","version":null,"tagName":"h3"},{"title":"GetFor​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#GetFor","content":"&lt;/&gt; RemoteProperty.GetFor( self: RemotePropertyInternal&lt;T&gt;, player: Player -- The player ) → T-- The value for this player Gets the value for a specific player. Returns the per-player override if set, otherwise the top value.  ","version":null,"tagName":"h3"},{"title":"Observe​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#Observe","content":"&lt;/&gt; RemoteProperty.Observe( self: RemotePropertyInternal&lt;T&gt;, callback: (value: T) → ()-- The callback function ) → Connection-- The connection Observes changes to the top value. The callback fires immediately with the current value, then on each change.  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"RemoteProperty","url":"/e2en/api/RemoteProperty#Destroy","content":"&lt;/&gt; RemoteProperty.Destroy(self: RemotePropertyInternal&lt;T&gt;) → () Destroys the property and its underlying network objects. ","version":null,"tagName":"h3"},{"title":"Signal","type":0,"sectionRef":"#","url":"/e2en/api/Signal","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#types","content":" ","version":null,"tagName":"h2"},{"title":"SignalConnection​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Connected: boolean Disconnect: (SignalConnection) → () } Represents a connection to a signal. local connection = signal:Connect(function() end) print(connection.Connected) --&gt; true connection:Disconnect() print(connection.Connected) --&gt; false   ","version":null,"tagName":"h3"},{"title":"ConnectionFn​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#ConnectionFn","content":"&lt;/&gt; type ConnectionFn = (...any) → () A function connected to a signal. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal  ","version":null,"tagName":"h3"},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal -- Existing RBXScriptSignal to wrap ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   ","version":null,"tagName":"h3"},{"title":"Is​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#Is","content":"&lt;/&gt; Signal.Is( obj: any-- Object to check ) → boolean-- true if the object is a Signal. Checks if the given object is a Signal.  ","version":null,"tagName":"h3"},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called anytime the signal is fired. signal:Connect(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25)   ","version":null,"tagName":"h3"},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#Once","content":"&lt;/&gt; Signal:Once(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called the next time the signal fires. Once the connection is triggered, it will disconnect itself. signal:Once(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25) signal:Fire(&quot;This message will not go through&quot;, 10)   ","version":null,"tagName":"h3"},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnects all connections from the signal. signal:DisconnectAll()   ","version":null,"tagName":"h3"},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: any) → () Fire the signal, which will call all of the connected functions with the given arguments. signal:Fire(&quot;Hello&quot;) -- Any number of arguments can be fired: signal:Fire(&quot;Hello&quot;, 32, {Test = &quot;Test&quot;}, true)   ","version":null,"tagName":"h3"},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred(...: any) → () Same as Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse. signal:FireDeferred(&quot;Hello&quot;)   ","version":null,"tagName":"h3"},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any Yields the current thread until the signal is fired, and returns the arguments fired from the signal. Yielding the current thread is not always desirable. If the desire is to only capture the next event fired, using Once might be a better solution. task.spawn(function() local msg, num = signal:Wait() print(msg, num) --&gt; &quot;Hello&quot;, 32 end) signal:Fire(&quot;Hello&quot;, 32)   ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal. Technically, this is only necessary if the signal is created usingSignal.Wrap. Connections should be properly GC'd once the signal is no longer referenced anywhere. However, it is still good practice to include ways to strictly clean up resources. Calling Destroy on a signal will also disconnect all connections immediately. signal:Destroy()   ","version":null,"tagName":"h3"},{"title":"ConnectOnce​","type":1,"pageTitle":"Signal","url":"/e2en/api/Signal#ConnectOnce","content":"deprecated in v1.3.0 &lt;/&gt; This was deprecated in v1.3.0 Use `Signal:Once` instead. Signal:ConnectOnce(fn: ConnectionFn) → SignalConnection  ","version":null,"tagName":"h3"},{"title":"Trove","type":0,"sectionRef":"#","url":"/e2en/api/Trove","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#new","content":"&lt;/&gt; Trove.new() → Trove Constructs a Trove object.  ","version":null,"tagName":"h3"},{"title":"Extend​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#Extend","content":"&lt;/&gt; Trove:Extend() → Trove Creates and adds another trove to itself. This is just shorthand for trove:Construct(Trove). This is useful for contexts where the trove object is present, but the class itself isn't. NOTE This does not clone the trove. In other words, the objects in the trove are not given to the new constructed trove. This is simply to construct a new Trove and add it as an object to track. local trove = Trove.new() local subTrove = trove:Extend() trove:Clean() -- Cleans up the subTrove too   ","version":null,"tagName":"h3"},{"title":"Clone​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#Clone","content":"&lt;/&gt; Trove:Clone(instance: Instance ) → Instance  Clones the given instance and adds it to the trove. Shorthand fortrove:Add(instance:Clone()).  ","version":null,"tagName":"h3"},{"title":"Construct​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#Construct","content":"&lt;/&gt; Trove:Construct( class: table | (...any) → any, ...: any ) → any Constructs a new object from either the table or function given. If a table is given, the table's new function will be called with the given arguments. If a function is given, the function will be called with the given arguments. The result from either of the two options will be added to the trove. This is shorthand for trove:Add(SomeClass.new(...)) and trove:Add(SomeFunction(...)). local Signal = require(somewhere.Signal) -- All of these are identical: local s = trove:Construct(Signal) local s = trove:Construct(Signal.new) local s = trove:Construct(function() return Signal.new() end) local s = trove:Add(Signal.new()) -- Even Roblox instances can be created: local part = trove:Construct(Instance, &quot;Part&quot;)   ","version":null,"tagName":"h3"},{"title":"Connect​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#Connect","content":"&lt;/&gt; Trove:Connect( signal: RBXScriptSignal , fn: (...: any): () → () ) → RBXScriptConnection  Connects the function to the signal, adds the connection to the trove, and then returns the connection. This is shorthand for trove:Add(signal:Connect(fn)). trove:Connect(workspace.ChildAdded, function(instance) print(instance.Name .. &quot; added to workspace&quot;) end)   ","version":null,"tagName":"h3"},{"title":"ClassConnect​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#ClassConnect","content":"&lt;/&gt; Trove:ClassConnect( signal: RBXScriptSignal , method: (...: any): () → (), class: ([any]: any) ) → RBXScriptConnection  Connects the function to the signal, adds the connection to the trove, and then returns the connection. This is shorthand for trove:Add(signal:Connect(function(...) Class.Method(Class, ...) end)). trove:ClassConnect(workspace.ChildAdded, Class.Method, Class)   ","version":null,"tagName":"h3"},{"title":"BindToRenderStep​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#BindToRenderStep","content":"&lt;/&gt; Trove:BindToRenderStep( name: string, priority: number, fn: (dt: number) → () ) → () Calls RunService:BindToRenderStep and registers a function in the trove that will call RunService:UnbindFromRenderStep on cleanup. trove:BindToRenderStep(&quot;Test&quot;, Enum.RenderPriority.Last.Value, function(dt) -- Do something end)   ","version":null,"tagName":"h3"},{"title":"AddPromise​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#AddPromise","content":"&lt;/&gt; Trove:AddPromise(promise: Promise) → Promise Gives the promise to the trove, which will cancel the promise if the trove is cleaned up or if the promise is removed. The exact promise is returned, thus allowing chaining. trove:AddPromise(doSomethingThatReturnsAPromise()) :andThen(function() print(&quot;Done&quot;) end) -- Will cancel the above promise (assuming it didn't resolve immediately) trove:Clean() local p = trove:AddPromise(doSomethingThatReturnsAPromise()) -- Will also cancel the promise trove:Remove(p) Promise v4 Only This is only compatible with the roblox-lua-promise library, version 4.  ","version":null,"tagName":"h3"},{"title":"Add​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#Add","content":"&lt;/&gt; Trove:Add( object: any,-- Object to track cleanupMethod: string?-- Optional cleanup name override ) → object: any Adds an object to the trove. Once the trove is cleaned or destroyed, the object will also be cleaned up. The following types are accepted (e.g. typeof(object)): Type Cleanup Instance object:Destroy() RBXScriptConnection object:Disconnect() function object() thread coroutine.close(object) table object:Destroy() or object:Disconnect() table with cleanupMethod object:&lt;cleanupMethod&gt;() Returns the object added. -- Add a part to the trove, then destroy the trove, -- which will also destroy the part: local part = Instance.new(&quot;Part&quot;) trove:Add(part) trove:Destroy() -- Add a function to the trove: trove:Add(function() print(&quot;Cleanup!&quot;) end) trove:Destroy() -- Standard cleanup from table: local tbl = {} function tbl:Destroy() print(&quot;Cleanup&quot;) end trove:Add(tbl) -- Custom cleanup from table: local tbl = {} function tbl:DoSomething() print(&quot;Do something on cleanup&quot;) end trove:Add(tbl, &quot;DoSomething&quot;)   ","version":null,"tagName":"h3"},{"title":"Remove​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#Remove","content":"&lt;/&gt; Trove:Remove( object: any-- Object to remove ) → boolean Removes the object from the Trove and cleans it up. local part = Instance.new(&quot;Part&quot;) trove:Add(part) trove:Remove(part)   ","version":null,"tagName":"h3"},{"title":"Clean​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#Clean","content":"&lt;/&gt; Trove:Clean() → () Cleans up all objects in the trove. This is similar to calling Remove on each object within the trove. The ordering of the objects removed is not guaranteed.  ","version":null,"tagName":"h3"},{"title":"AttachToInstance​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#AttachToInstance","content":"&lt;/&gt; Trove:AttachToInstance(instance: Instance ) → RBXScriptConnection  Attaches the trove to a Roblox instance. Once this instance is removed from the game (parent or ancestor's parent set to nil), the trove will automatically clean up. CAUTION Will throw an error if instance is not a descendant of the game hierarchy.  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Trove","url":"/e2en/api/Trove#Destroy","content":"&lt;/&gt; Trove:Destroy() → () Alias for trove:Clean(). ","version":null,"tagName":"h3"},{"title":"Server","type":0,"sectionRef":"#","url":"/e2en/api/Server","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#functions","content":" ","version":null,"tagName":"h2"},{"title":"CreateService​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#CreateService","content":"&lt;/&gt; Server.CreateService( definition: ServiceDefinition-- The service definition table ) → Service-- The created service Creates a new service. Services are server-side singletons that handle game logic. The Client table defines what is exposed to clients (signals, properties, and methods). local MyService = e2en.CreateService({ Name = &quot;MyService&quot;, Client = { DataChanged = e2en.CreateSignal(), CurrentData = e2en.CreateProperty(0), }, }) function MyService:Init() print(&quot;Initializing&quot;) end function MyService:Start() print(&quot;Starting&quot;) end   ","version":null,"tagName":"h3"},{"title":"GetService​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#GetService","content":"&lt;/&gt; Server.GetService( serviceName: string-- The name of the service ) → Service-- The service instance Gets a service by name. local DataService = e2en.GetService(&quot;DataService&quot;)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Server","url":"/e2en/api/Server##","content":"Type\tDescription&quot;Service not found&quot;\tIf no service with the given name exists  ","version":null,"tagName":"h3"},{"title":"GetServices​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#GetServices","content":"&lt;/&gt; Server.GetServices() → {[string]: Service}-- Dictionary of service name to service instance Gets all registered services.  ","version":null,"tagName":"h3"},{"title":"AddServices​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#AddServices","content":"&lt;/&gt; Server.AddServices( parent: Instance -- Parent container to search ) → {Service}-- Array of loaded services Loads services from direct children ModuleScripts.  ","version":null,"tagName":"h3"},{"title":"AddServicesDeep​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#AddServicesDeep","content":"&lt;/&gt; Server.AddServicesDeep( parent: Instance -- Parent container to search ) → {Service}-- Array of loaded services Loads services from all descendant ModuleScripts.  ","version":null,"tagName":"h3"},{"title":"AddSystems​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#AddSystems","content":"&lt;/&gt; Server.AddSystems( parent: Instance -- Parent container with system folders ) → {Service}-- Array of loaded services Loads services from Service.luau files in direct child folders. This is the recommended way to organize services. Each system folder contains a Service.luau file. Systems/ ├── Combat/ │ └── Service.luau ← Loaded ├── Inventory/ │ └── Service.luau ← Loaded   ","version":null,"tagName":"h3"},{"title":"AddSystemsDeep​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#AddSystemsDeep","content":"&lt;/&gt; Server.AddSystemsDeep( parent: Instance -- Parent container to search recursively ) → {Service}-- Array of loaded services Loads services from Service.luau files in all descendant folders.  ","version":null,"tagName":"h3"},{"title":"CreateSignal​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#CreateSignal","content":"&lt;/&gt; Server.CreateSignal() → SignalMarker Creates a signal marker for use in a Service's Client table. The marker is replaced with a RemoteSignal when the service is processed. Client = { PlayerDied = e2en.CreateSignal(), }   ","version":null,"tagName":"h3"},{"title":"CreateUnreliableSignal​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#CreateUnreliableSignal","content":"&lt;/&gt; Server.CreateUnreliableSignal() → UnreliableSignalMarker Creates an unreliable signal marker for high-frequency, loss-tolerant data. Uses UnreliableRemoteEvent under the hood for lower latency. Client = { PositionUpdate = e2en.CreateUnreliableSignal(), }   ","version":null,"tagName":"h3"},{"title":"CreateProperty​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#CreateProperty","content":"&lt;/&gt; Server.CreateProperty( initialValue: T-- The initial value for the property ) → PropertyMarker&lt;T&gt; Creates a property marker for replicated state. The marker is replaced with a RemoteProperty when the service is processed. Properties support per-player overrides. Client = { Coins = e2en.CreateProperty(0), Inventory = e2en.CreateProperty({}), }   ","version":null,"tagName":"h3"},{"title":"OnPlayerAdded​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#OnPlayerAdded","content":"&lt;/&gt; Server.OnPlayerAdded( callback: ( player: Player , trove: Trove ) → ()-- The callback function ) → () Registers a callback for when players join. The callback fires immediately for players already in the game. The trove auto-cleans when the player leaves. e2en.OnPlayerAdded(function(player, trove) print(player.Name, &quot;joined&quot;) trove:Add(createPlayerState(player)) end)   ","version":null,"tagName":"h3"},{"title":"OnPlayerRemoving​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#OnPlayerRemoving","content":"&lt;/&gt; Server.OnPlayerRemoving( callback: (player: Player ) → ()-- The callback function ) → () Registers a callback for when players leave. Use this for saving data before the player is removed. e2en.OnPlayerRemoving(function(player) savePlayerData(player) end)   ","version":null,"tagName":"h3"},{"title":"OnCharacterAdded​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#OnCharacterAdded","content":"&lt;/&gt; Server.OnCharacterAdded( callback: ( player: Player , character: Model , trove: Trove ) → ()-- The callback function ) → () Registers a callback for when characters spawn. The callback fires immediately for existing characters. The trove auto-cleans when the character is removed. e2en.OnCharacterAdded(function(player, character, trove) local humanoid = character:WaitForChild(&quot;Humanoid&quot;) trove:Connect(humanoid.Died, function() print(player.Name, &quot;died&quot;) end) end)   ","version":null,"tagName":"h3"},{"title":"OnCharacterRemoving​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#OnCharacterRemoving","content":"&lt;/&gt; Server.OnCharacterRemoving( callback: ( player: Player , character: Model ) → ()-- The callback function ) → () Registers a callback for when characters are removed. e2en.OnCharacterRemoving(function(player, character) print(player.Name, &quot;character removing&quot;) end)   ","version":null,"tagName":"h3"},{"title":"GetPlayerTrove​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#GetPlayerTrove","content":"&lt;/&gt; Server.GetPlayerTrove( player: Player -- The player ) → Trove?-- The player's trove, or nil Gets the trove associated with a player. Returns nil if the player is not in the game.  ","version":null,"tagName":"h3"},{"title":"GetCharacterTrove​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#GetCharacterTrove","content":"&lt;/&gt; Server.GetCharacterTrove( player: Player -- The player ) → Trove?-- The character's trove, or nil Gets the trove associated with a player's current character. Returns nil if the player has no character.  ","version":null,"tagName":"h3"},{"title":"Start​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#Start","content":"&lt;/&gt; Server.Start( config: RunConfig?-- Optional configuration with middleware ) → () Starts the framework manually. Most users should use e2en.Run() instead, which handles environment allocation and system discovery automatically.  ","version":null,"tagName":"h3"},{"title":"OnStart​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#OnStart","content":"&lt;/&gt; Server.OnStart() → () Yields until the framework has finished starting. e2en.OnStart() print(&quot;Framework is ready!&quot;)   ","version":null,"tagName":"h3"},{"title":"IsStarted​","type":1,"pageTitle":"Server","url":"/e2en/api/Server#IsStarted","content":"&lt;/&gt; Server.IsStarted() → boolean-- True if the framework has started Checks if the framework has finished starting. ","version":null,"tagName":"h3"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/e2en/docs/getting-started","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/e2en/docs/getting-started#installation","content":" Download or clone the repository from GitHubPlace the e2en folder in ServerScriptService  ","version":"Next","tagName":"h2"},{"title":"Project Structure​","type":1,"pageTitle":"Getting Started","url":"/e2en/docs/getting-started#project-structure","content":" e2en expects this folder structure:  ServerScriptService/ └── e2en/ └── src/ ├── init.luau ├── Systems/ -- Your game systems go here │ └── Example/ │ ├── Service.luau │ └── Controller.luau ├── Shared/ │ └── common/ -- Shared data, configs └── Environment/ -- StarterGui, StarterPlayerScripts, etc. src/ └── server/ └── Loader.server.luau -- Server entry point   ","version":"Next","tagName":"h2"},{"title":"Server Setup​","type":1,"pageTitle":"Getting Started","url":"/e2en/docs/getting-started#server-setup","content":" Create a loader script that starts the framework. Place this in ServerScriptService or your equivalent server scripts folder.  -- Loader.server.luau local ServerScriptService = game:GetService(&quot;ServerScriptService&quot;) local Types = require(ServerScriptService.e2en.Types) local e2en: Types.e2enServer = require(ServerScriptService.e2en) :: any e2en.Run()   That's it. Run() does several things automatically:  Moves assets from Environment/ to their proper locations (StarterGui, etc.)Discovers and loads all Services from Systems/Replicates the framework to clients (stripping server-only code)Initializes and starts all Services in dependency order  ","version":"Next","tagName":"h2"},{"title":"Creating Your First Service​","type":1,"pageTitle":"Getting Started","url":"/e2en/docs/getting-started#creating-your-first-service","content":" Services are server-side singletons. Create one in Systems/MySystem/Service.luau:  local root = script.Parent.Parent.Parent local Types = require(root.Types) local e2en: Types.e2enServer = require(root) :: any local MyService = e2en.CreateService({ Name = &quot;MyService&quot;, Client = { -- Things clients can access SomethingHappened = e2en.CreateSignal(), CurrentScore = e2en.CreateProperty(0), }, }) function MyService:Init() -- Called synchronously during startup -- Safe to call GetService() for dependencies print(&quot;MyService initializing&quot;) end function MyService:Start() -- Called after all Services have initialized -- Runs asynchronously print(&quot;MyService started&quot;) end function MyService:AddScore(player: Player, amount: number) local currentScore = self.Client.CurrentScore:GetFor(player) self.Client.CurrentScore:SetFor(player, currentScore + amount) end return MyService   ","version":"Next","tagName":"h2"},{"title":"Creating Your First Controller​","type":1,"pageTitle":"Getting Started","url":"/e2en/docs/getting-started#creating-your-first-controller","content":" Controllers are client-side singletons. Create one in Systems/MySystem/Controller.luau:  local root = script.Parent.Parent.Parent local Types = require(root.Types) local e2en: Types.e2enClient = require(root) :: any local MyController = e2en.CreateController({ Name = &quot;MyController&quot;, }) function MyController:Init() print(&quot;MyController initializing&quot;) end function MyController:Start() -- Access server services local MyService = e2en.GetService(&quot;MyService&quot;) -- Listen for server events MyService.SomethingHappened:Connect(function(data) print(&quot;Server said:&quot;, data) end) -- Observe replicated state MyService.CurrentScore:Observe(function(score) print(&quot;Score updated:&quot;, score) end) end return MyController   ","version":"Next","tagName":"h2"},{"title":"Understanding the Lifecycle​","type":1,"pageTitle":"Getting Started","url":"/e2en/docs/getting-started#understanding-the-lifecycle","content":" When e2en.Run() is called:  Server Client ────── ────── 1. Environment allocated 2. Systems discovered 3. Framework replicated to client ──────&gt; Client receives framework 4. Init() called (sync, in order) Init() called (sync, in order) 5. Player lifecycle setup 6. Start() called (async) Start() called (async) 7. Services exposed to clients   ","version":"Next","tagName":"h2"},{"title":"Init vs Start​","type":1,"pageTitle":"Getting Started","url":"/e2en/docs/getting-started#init-vs-start","content":" Phase\tWhen\tUse ForInit()\tSynchronous, dependency order\tSetting up references, registering handlers Start()\tAsynchronous, after all Init\tStarting game loops, initial data loads  In Init(), you can safely call GetService() or GetController() for any declared dependency. In Start(), everything is available.  ","version":"Next","tagName":"h3"},{"title":"Dependencies​","type":1,"pageTitle":"Getting Started","url":"/e2en/docs/getting-started#dependencies","content":" If your Service needs another Service during Init(), declare the dependency:  local MyService = e2en.CreateService({ Name = &quot;MyService&quot;, Dependencies = { &quot;DataService&quot;, &quot;PlayerService&quot; }, }) function MyService:Init() -- DataService and PlayerService are guaranteed to be initialized local DataService = e2en.GetService(&quot;DataService&quot;) end   ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Getting Started","url":"/e2en/docs/getting-started#next-steps","content":" Now that you have the basics:  Services - Deep dive into server-side architectureControllers - Client-side patterns and UI integrationCommunication - RemoteSignals and RemotePropertiesLifecycle - Player and character lifecycle management ","version":"Next","tagName":"h2"},{"title":"Communication","type":0,"sectionRef":"#","url":"/e2en/docs/communication","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#overview","content":" Type\tDirection\tUse CaseRemote Method\tClient → Server\tRequest/response calls Remote Signal\tBoth\tFire-and-forget events Remote Property\tServer → Client\tReplicated state  ","version":"Next","tagName":"h2"},{"title":"Remote Methods​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#remote-methods","content":" Functions in a Service's Client table become callable from clients.  ","version":"Next","tagName":"h2"},{"title":"Server Definition​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#server-definition","content":" local ShopService = e2en.CreateService({ Name = &quot;ShopService&quot;, Client = { GetItems = function(self, player: Player): {any} return getAvailableItems() end, Purchase = function(self, player: Player, itemId: string): (boolean, string?) if typeof(itemId) ~= &quot;string&quot; then return false, &quot;Invalid item&quot; end if not canAfford(player, itemId) then return false, &quot;Not enough coins&quot; end giveItem(player, itemId) return true, nil end, }, })   ","version":"Next","tagName":"h3"},{"title":"Client Usage​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#client-usage","content":" local ShopService = e2en.GetService(&quot;ShopService&quot;) -- Call like a method (player is automatically passed) local items = ShopService:GetItems() local success, error = ShopService:Purchase(&quot;sword_01&quot;) if not success then print(&quot;Failed:&quot;, error) end   ","version":"Next","tagName":"h3"},{"title":"Security​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#security","content":" Always Validate Remote methods are called by clients. Never trust the arguments: Purchase = function(self, player: Player, itemId: any, quantity: any) -- Validate types if typeof(itemId) ~= &quot;string&quot; then return false end if typeof(quantity) ~= &quot;number&quot; then return false end if quantity &lt; 1 or quantity &gt; 99 then return false end if math.floor(quantity) ~= quantity then return false end -- Now safe to use ... end   ","version":"Next","tagName":"h3"},{"title":"Remote Signals​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#remote-signals","content":" Signals are fire-and-forget events that can flow both directions.  ","version":"Next","tagName":"h2"},{"title":"Creating a Signal​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#creating-a-signal","content":" local CombatService = e2en.CreateService({ Name = &quot;CombatService&quot;, Client = { DamageDealt = e2en.CreateSignal(), PlayerKilled = e2en.CreateSignal(), }, })   ","version":"Next","tagName":"h3"},{"title":"Server → Client​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#server--client","content":" Fire to One Player​  self.Client.DamageDealt:Fire(player, { amount = 25, source = &quot;Enemy&quot; })   Fire to All Players​  self.Client.PlayerKilled:FireAll({ victim = &quot;Player1&quot;, killer = &quot;Player2&quot; })   Fire to Multiple Players​  local team = getTeamPlayers(&quot;Red&quot;) self.Client.DamageDealt:FireFor(team, { amount = 10 })   Fire to All Except One​  self.Client.DamageDealt:FireExcept(excludedPlayer, data)   Fire with Filter​  self.Client.DamageDealt:FireFilter(function(player) return player.Team == Teams.Blue end, data)   ","version":"Next","tagName":"h3"},{"title":"Client → Server​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#client--server","content":" Clients can fire signals back:  -- Client local CombatService = e2en.GetService(&quot;CombatService&quot;) CombatService.DamageDealt:Fire({ target = &quot;Enemy1&quot; }) -- Server (listen for client fires) self.Client.DamageDealt:Connect(function(player, data) -- Validate! if typeof(data) ~= &quot;table&quot; then return end if typeof(data.target) ~= &quot;string&quot; then return end handlePlayerAttack(player, data.target) end)   ","version":"Next","tagName":"h3"},{"title":"Client Listening​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#client-listening","content":" local CombatService = e2en.GetService(&quot;CombatService&quot;) CombatService.DamageDealt:Connect(function(data) print(&quot;Took damage:&quot;, data.amount) showDamageEffect(data.amount) end)   ","version":"Next","tagName":"h3"},{"title":"Unreliable Signals​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#unreliable-signals","content":" For high-frequency data where occasional packet loss is acceptable:  Client = { PositionUpdate = e2en.CreateUnreliableSignal(), } -- Uses UnreliableRemoteEvent under the hood -- Lower latency, but packets may be dropped   ","version":"Next","tagName":"h3"},{"title":"Remote Properties​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#remote-properties","content":" Properties replicate state from server to client with built-in observation.  ","version":"Next","tagName":"h2"},{"title":"Creating a Property​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#creating-a-property","content":" local GameService = e2en.CreateService({ Name = &quot;GameService&quot;, Client = { GamePhase = e2en.CreateProperty(&quot;Waiting&quot;), RoundTime = e2en.CreateProperty(0), Scores = e2en.CreateProperty({}), }, })   ","version":"Next","tagName":"h3"},{"title":"Server: Setting Values​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#server-setting-values","content":" Set for All Players​  -- Clears per-player overrides self.Client.GamePhase:Set(&quot;Playing&quot;)   Set Top Value Only​  -- Sets the default without clearing per-player overrides self.Client.RoundTime:SetTop(60)   Set for Specific Player​  self.Client.Scores:SetFor(player, { kills = 5, deaths = 2 })   Set for Multiple Players​  self.Client.Scores:SetForList(teamPlayers, { kills = 0, deaths = 0 })   Set with Filter​  self.Client.Scores:SetFilter(function(player) return player:GetAttribute(&quot;VIP&quot;) end, specialScores)   ","version":"Next","tagName":"h3"},{"title":"Server: Reading Values​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#server-reading-values","content":" -- Get the top value local phase = self.Client.GamePhase:Get() -- Get value for specific player (respects per-player overrides) local playerScores = self.Client.Scores:GetFor(player)   ","version":"Next","tagName":"h3"},{"title":"Server: Clearing Overrides​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#server-clearing-overrides","content":" -- Player reverts to the top value self.Client.Scores:ClearFor(player) self.Client.Scores:ClearForList(players)   ","version":"Next","tagName":"h3"},{"title":"Server: Observing Changes​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#server-observing-changes","content":" -- Called immediately with current value, then on each change self.Client.GamePhase:Observe(function(phase) print(&quot;Phase changed to:&quot;, phase) end)   ","version":"Next","tagName":"h3"},{"title":"Client: Reading Values​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#client-reading-values","content":" local GameService = e2en.GetService(&quot;GameService&quot;) -- Get current value local phase = GameService.GamePhase:Get()   ","version":"Next","tagName":"h3"},{"title":"Client: Observing Changes​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#client-observing-changes","content":" -- Called immediately, then on each update GameService.GamePhase:Observe(function(phase) updatePhaseUI(phase) end)   ","version":"Next","tagName":"h3"},{"title":"Client: Waiting for Initial Value​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#client-waiting-for-initial-value","content":" -- Check if initial value received if GameService.Scores:IsReady() then local scores = GameService.Scores:Get() end -- Wait for ready (with optional timeout) local scores = GameService.Scores:OnReady(5) -- 5 second timeout if scores then print(&quot;Got scores:&quot;, scores) else print(&quot;Timed out waiting for scores&quot;) end   ","version":"Next","tagName":"h3"},{"title":"Per-Player Properties​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#per-player-properties","content":" Properties support per-player overrides—perfect for player-specific state:  local DataService = e2en.CreateService({ Name = &quot;DataService&quot;, Client = { Coins = e2en.CreateProperty(0), Inventory = e2en.CreateProperty({}), }, }) function DataService:Start() e2en.OnPlayerAdded(function(player, trove) -- Load player's data local data = loadPlayerData(player) -- Set their specific values self.Client.Coins:SetFor(player, data.coins) self.Client.Inventory:SetFor(player, data.inventory) end) end   On the client, each player sees only their own value:  local DataService = e2en.GetService(&quot;DataService&quot;) DataService.Coins:Observe(function(coins) -- This is MY coins, not another player's updateCoinsUI(coins) end)   ","version":"Next","tagName":"h2"},{"title":"Choosing the Right Type​","type":1,"pageTitle":"Communication","url":"/e2en/docs/communication#choosing-the-right-type","content":" Scenario\tUseClient requests data\tRemote Method Client performs action\tRemote Method Server notifies one-time event\tRemote Signal High-frequency updates (positions)\tUnreliable Signal Persistent replicated state\tRemote Property Per-player state\tRemote Property with SetFor ","version":"Next","tagName":"h2"},{"title":"Components","type":0,"sectionRef":"#","url":"/e2en/docs/components","content":"","keywords":"","version":"Next"},{"title":"Creating a Component​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#creating-a-component","content":" local root = script.Parent.Parent.Parent local Component = require(root.Libraries.Component) local Lava = Component.new({ Tag = &quot;Lava&quot;, Ancestors = { workspace }, -- Optional: only track in workspace }) -- Define properties on the prototype Lava._prototype.Damage = 10 Lava._prototype.DamageInterval = 0.5 -- Lifecycle methods function Lava._prototype:Construct() -- Called when component is created print(&quot;Lava created on&quot;, self.Instance.Name) end function Lava._prototype:Start() -- Called after Construct, safe to interact with other components self._lastDamageTime = {} self._trove:Connect(self.Instance.Touched, function(hit) self:OnTouched(hit) end) end function Lava._prototype:Stop() -- Called before cleanup print(&quot;Lava removed from&quot;, self.Instance.Name) end -- Custom methods function Lava._prototype:OnTouched(hit: BasePart) local character = hit.Parent local humanoid = character and character:FindFirstChild(&quot;Humanoid&quot;) :: Humanoid? if humanoid and humanoid.Health &gt; 0 then local now = os.clock() local lastDamage = self._lastDamageTime[character] or 0 if now - lastDamage &gt;= self.DamageInterval then humanoid:TakeDamage(self.Damage) self._lastDamageTime[character] = now end end end -- Start tracking tagged instances Lava:Start() return Lava   ","version":"Next","tagName":"h2"},{"title":"Component Lifecycle​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#component-lifecycle","content":" Instance tagged with &quot;Lava&quot; │ ▼ ┌─────────────────┐ │ Construct() │ Component instance created └─────────────────┘ │ ▼ ┌─────────────────┐ │ Start() │ Safe to interact with world └─────────────────┘ │ │ (component active...) │ ▼ ┌─────────────────┐ │ Stop() │ Cleanup begins └─────────────────┘ │ ▼ _trove:Clean() Automatic cleanup │ ▼ Component destroyed   ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#configuration","content":" local MyComponent = Component.new({ Tag = &quot;MyTag&quot;, -- Required: CollectionService tag Ancestors = { workspace, ReplicatedStorage }, -- Optional: only track in these })   If Ancestors is not specified, all tagged instances are tracked regardless of location.  ","version":"Next","tagName":"h2"},{"title":"The Prototype​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#the-prototype","content":" Define properties and methods on _prototype:  -- Properties (copied to each instance) MyComponent._prototype.Speed = 10 MyComponent._prototype.MaxHealth = 100 -- Methods (shared via metatable) function MyComponent._prototype:TakeDamage(amount) self.Health = math.max(0, self.Health - amount) end   ","version":"Next","tagName":"h2"},{"title":"Built-in Properties​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#built-in-properties","content":" Every component instance has:  Property\tType\tDescriptionInstance\tInstance\tThe tagged Roblox instance _trove\tTrove\tAuto-cleans when component is destroyed  ","version":"Next","tagName":"h2"},{"title":"Update Loops​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#update-loops","content":" Components can opt into per-frame updates:  -- Called every Heartbeat function MyComponent._prototype:HeartbeatUpdate(dt: number) self.Instance.CFrame *= CFrame.Angles(0, dt, 0) end -- Called every RenderStepped (client only) function MyComponent._prototype:RenderSteppedUpdate(dt: number) -- Client-side rendering logic end   Update methods are only connected if they're defined on the prototype.  ","version":"Next","tagName":"h2"},{"title":"Accessing Components​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#accessing-components","content":" ","version":"Next","tagName":"h2"},{"title":"Get Component from Instance​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#get-component-from-instance","content":" local lavaComponent = Lava:FromInstance(somePart) if lavaComponent then print(&quot;Damage:&quot;, lavaComponent.Damage) lavaComponent.Damage = 20 -- Modify this instance end   ","version":"Next","tagName":"h3"},{"title":"Get All Active Components​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#get-all-active-components","content":" local allLava = Lava:GetAll() for _, component in allLava do print(component.Instance.Name, &quot;deals&quot;, component.Damage, &quot;damage&quot;) end   ","version":"Next","tagName":"h3"},{"title":"Wait for Component​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#wait-for-component","content":" -- Yields until component exists (with timeout) local component = Lava:WaitForInstance(somePart, 5) if component then print(&quot;Found!&quot;) else print(&quot;Timed out&quot;) end   ","version":"Next","tagName":"h3"},{"title":"Component Signals​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#component-signals","content":" React to components being added or removed:  Lava.ComponentAdded:Connect(function(component) print(&quot;New lava on&quot;, component.Instance.Name) end) Lava.ComponentRemoving:Connect(function(component) print(&quot;Lava being removed from&quot;, component.Instance.Name) end)   ","version":"Next","tagName":"h2"},{"title":"Using Trove​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#using-trove","content":" Each component has a _trove that auto-cleans when destroyed:  function MyComponent._prototype:Start() -- Connections auto-disconnect self._trove:Connect(self.Instance.Touched, function(hit) self:OnTouched(hit) end) -- Instances auto-destroy local highlight = Instance.new(&quot;Highlight&quot;) self._trove:Add(highlight) highlight.Parent = self.Instance -- Custom cleanup local resource = createResource() self._trove:Add(resource, &quot;Release&quot;) end   ","version":"Next","tagName":"h2"},{"title":"Destroying Components​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#destroying-components","content":" ","version":"Next","tagName":"h2"},{"title":"Remove Tag​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#remove-tag","content":" -- Component is destroyed when tag is removed local CollectionService = game:GetService(&quot;CollectionService&quot;) CollectionService:RemoveTag(part, &quot;Lava&quot;)   ","version":"Next","tagName":"h3"},{"title":"Destroy Instance​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#destroy-instance","content":" -- Component is destroyed when instance is destroyed part:Destroy()   ","version":"Next","tagName":"h3"},{"title":"Destroy Component Class​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#destroy-component-class","content":" -- Stops tracking and destroys all instances Lava:Destroy()   ","version":"Next","tagName":"h3"},{"title":"Example: Collectible​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#example-collectible","content":" local Component = require(root.Libraries.Component) local Collectible = Component.new({ Tag = &quot;Collectible&quot;, Ancestors = { workspace }, }) Collectible._prototype.Value = 10 Collectible._prototype.RespawnTime = 30 function Collectible._prototype:Construct() self._originalCFrame = self.Instance.CFrame self._collected = false end function Collectible._prototype:Start() self._trove:Connect(self.Instance.Touched, function(hit) self:OnTouched(hit) end) end function Collectible._prototype:HeartbeatUpdate(dt: number) if not self._collected then -- Spin and bob local time = os.clock() self.Instance.CFrame = self._originalCFrame * CFrame.Angles(0, time * 2, 0) * CFrame.new(0, math.sin(time * 3) * 0.5, 0) end end function Collectible._prototype:OnTouched(hit: BasePart) if self._collected then return end local player = game.Players:GetPlayerFromCharacter(hit.Parent) if not player then return end self._collected = true self.Instance.Transparency = 1 -- Award points (via service) local PointsService = e2en.GetService(&quot;PointsService&quot;) PointsService:AddPoints(player, self.Value) -- Respawn after delay task.delay(self.RespawnTime, function() if self.Instance and self.Instance.Parent then self._collected = false self.Instance.Transparency = 0 end end) end Collectible:Start() return Collectible   ","version":"Next","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Components","url":"/e2en/docs/components#best-practices","content":" Keep components focused - One responsibility per componentUse Trove - Always clean up via _trove, not manual trackingValidate Instance - Check self.Instance still exists in delayed callbacksAncestors filter - Use Ancestors to avoid tracking instances in unexpected placesHeartbeatUpdate for logic - Use RenderSteppedUpdate only for visual client-side updates ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/e2en/docs/intro","content":"","keywords":"","version":"Next"},{"title":"What It Does​","type":1,"pageTitle":"Introduction","url":"/e2en/docs/intro#what-it-does","content":" e2en separates server and client code into Services and Controllers, groups related code into Systems, and handles networking automatically. Here's the basic structure:  Systems/ ├── Combat/ │ ├── Service.luau -- Server logic │ ├── Controller.luau -- Client logic │ └── Shared/ -- Shared code ├── Inventory/ │ ├── Service.luau │ └── Controller.luau   ","version":"Next","tagName":"h2"},{"title":"Automatic Networking​","type":1,"pageTitle":"Introduction","url":"/e2en/docs/intro#automatic-networking","content":" Services can expose signals, properties, and methods to clients without manually creating RemoteEvents.  -- Server local CombatService = e2en.CreateService({ Name = &quot;CombatService&quot;, Client = { DamageDealt = e2en.CreateSignal(), -- Clients can listen PlayerHealth = e2en.CreateProperty(100), -- Synced state }, }) -- Later on the server... self.Client.DamageDealt:Fire(player, { amount = 25 }) self.Client.PlayerHealth:SetFor(player, 75)   -- Client (automatically available) local CombatService = e2en.GetService(&quot;CombatService&quot;) CombatService.DamageDealt:Connect(function(data) print(&quot;Took&quot;, data.amount, &quot;damage&quot;) end) CombatService.PlayerHealth:Observe(function(health) updateHealthBar(health) end)   ","version":"Next","tagName":"h3"},{"title":"Type Safety​","type":1,"pageTitle":"Introduction","url":"/e2en/docs/intro#type-safety","content":" Written in strict Luau with full type annotations.  local e2en: Types.e2enServer = require(root) :: any   ","version":"Next","tagName":"h3"},{"title":"Lifecycle Management​","type":1,"pageTitle":"Introduction","url":"/e2en/docs/intro#lifecycle-management","content":" Player and character lifecycle hooks with automatic cleanup via Trove integration.  e2en.OnCharacterAdded(function(player, character, trove) -- This connection is automatically disconnected when character dies trove:Connect(character.Humanoid.Running, function(speed) print(player.Name, &quot;running at&quot;, speed) end) end)   ","version":"Next","tagName":"h3"},{"title":"Core Concepts​","type":1,"pageTitle":"Introduction","url":"/e2en/docs/intro#core-concepts","content":" Concept\tDescriptionService\tServer-side singleton that handles game logic. Can expose signals, properties, and methods to clients. Controller\tClient-side singleton that handles local logic and UI. Can communicate with Services. System\tA folder containing a Service and/or Controller that work together. Keeps related code organized. RemoteSignal\tServer-to-client event system. Fire to one player, all players, or filtered subsets. RemoteProperty\tReplicated state with per-player overrides. Clients observe changes reactively.  ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Introduction","url":"/e2en/docs/intro#next-steps","content":" Getting Started covers installation and setup.  Other topics:  Services - Server-side architectureControllers - Client-side architectureCommunication - Networking between server and clientLifecycle - Player and character event handling ","version":"Next","tagName":"h2"},{"title":"Controllers","type":0,"sectionRef":"#","url":"/e2en/docs/controllers","content":"","keywords":"","version":"Next"},{"title":"Creating a Controller​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#creating-a-controller","content":" local root = script.Parent.Parent.Parent local Types = require(root.Types) local e2en: Types.e2enClient = require(root) :: any local InventoryController = e2en.CreateController({ Name = &quot;InventoryController&quot;, }) function InventoryController:Init() -- Setup code end function InventoryController:Start() -- Runtime code end return InventoryController   ","version":"Next","tagName":"h2"},{"title":"Controller Definition​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#controller-definition","content":" Field\tType\tDescriptionName\tstring\tRequired. Unique identifier for the controller. Dependencies\t{string}\tControllers that must initialize before this one. Init\tfunction\tCalled synchronously during startup. Start\tfunction\tCalled asynchronously after all controllers initialize. custom\tany\tAny other fields become part of the controller table.  ","version":"Next","tagName":"h2"},{"title":"Accessing Server Services​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#accessing-server-services","content":" Use GetService() to get a proxy to a server Service:  function InventoryController:Start() local InventoryService = e2en.GetService(&quot;InventoryService&quot;) -- Call server methods local items = InventoryService:GetItems() -- Listen to server signals InventoryService.ItemAdded:Connect(function(item) self:OnItemAdded(item) end) -- Observe replicated properties InventoryService.InventorySize:Observe(function(size) self:UpdateInventoryUI(size) end) end   ","version":"Next","tagName":"h2"},{"title":"Accessing Other Controllers​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#accessing-other-controllers","content":" function InventoryController:Start() local UIController = e2en.GetController(&quot;UIController&quot;) UIController:ShowInventory() end   For Init() dependencies:  local InventoryController = e2en.CreateController({ Name = &quot;InventoryController&quot;, Dependencies = { &quot;UIController&quot; }, }) function InventoryController:Init() self._uiController = e2en.GetController(&quot;UIController&quot;) end   ","version":"Next","tagName":"h2"},{"title":"Working with UI​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#working-with-ui","content":" Controllers are the natural place for UI logic. e2en provides patterns for clean UI code.  ","version":"Next","tagName":"h2"},{"title":"UI Reference Pattern​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#ui-reference-pattern","content":" Initialize UI references at module scope using WaitForChild:  local Players = game:GetService(&quot;Players&quot;) local player = Players.LocalPlayer local PlayerGui = player.PlayerGui local root = script.Parent.Parent.Parent local Types = require(root.Types) local e2en: Types.e2enClient = require(root) :: any local InventoryController = e2en.CreateController({ Name = &quot;InventoryController&quot; }) -- UI references at module scope local InventoryGui = PlayerGui:WaitForChild(&quot;Inventory&quot;) :: ScreenGui local MainFrame = InventoryGui:WaitForChild(&quot;Main&quot;) :: Frame local ItemsContainer = MainFrame:WaitForChild(&quot;Items&quot;) :: ScrollingFrame local CloseButton = MainFrame:WaitForChild(&quot;Close&quot;) :: TextButton function InventoryController:Init() -- Wire up events CloseButton.Activated:Connect(function() self:Hide() end) end function InventoryController:Show() InventoryGui.Enabled = true end function InventoryController:Hide() InventoryGui.Enabled = false end return InventoryController   ","version":"Next","tagName":"h3"},{"title":"Why Module Scope?​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#why-module-scope","content":" Initializing UI at module scope instead of Init():  Fails fast - Missing UI elements error immediately on requireClear dependencies - All UI refs visible at top of fileType safety - Cast types once, use everywhereNo nil checks - Guaranteed to exist after module loads  ","version":"Next","tagName":"h3"},{"title":"Player Reference​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#player-reference","content":" Access the local player via e2en.Player:  function MyController:Start() local player = e2en.Player print(&quot;Local player:&quot;, player.Name) end   ","version":"Next","tagName":"h2"},{"title":"Character Access​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#character-access","content":" Get the current character or respond to character events:  function MyController:Start() -- Get current character (may be nil) local character = e2en.GetCharacter() -- React to character spawns e2en.OnCharacterAdded(function(character, trove) local humanoid = character:WaitForChild(&quot;Humanoid&quot;) -- Auto-cleanup when character dies trove:Connect(humanoid.Died, function() self:OnDied() end) end) end   ","version":"Next","tagName":"h2"},{"title":"Input Handling​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#input-handling","content":" Controllers handle player input:  local UserInputService = game:GetService(&quot;UserInputService&quot;) local ContextActionService = game:GetService(&quot;ContextActionService&quot;) local InputController = e2en.CreateController({ Name = &quot;InputController&quot; }) function InputController:Init() ContextActionService:BindAction( &quot;OpenInventory&quot;, function(_, state) if state == Enum.UserInputState.Begin then local InventoryController = e2en.GetController(&quot;InventoryController&quot;) InventoryController:Toggle() end end, false, Enum.KeyCode.I ) end return InputController   ","version":"Next","tagName":"h2"},{"title":"Loading Controllers​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#loading-controllers","content":" ","version":"Next","tagName":"h2"},{"title":"Automatic (Recommended)​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#automatic-recommended","content":" The client automatically loads Controllers from Systems/ folders:  Systems/ ├── Combat/ │ └── Controller.luau ← Loaded automatically ├── UI/ │ └── Controller.luau ← Loaded automatically   ","version":"Next","tagName":"h3"},{"title":"Manual Loading​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#manual-loading","content":" -- Load direct children e2en.AddControllers(someFolder) -- Load all descendants e2en.AddControllersDeep(someFolder) -- Load Controller.luau from immediate child folders e2en.AddSystems(someFolder) -- Load Controller.luau from all descendant folders e2en.AddSystemsDeep(someFolder)   ","version":"Next","tagName":"h3"},{"title":"Example: Complete Controller​","type":1,"pageTitle":"Controllers","url":"/e2en/docs/controllers#example-complete-controller","content":" local Players = game:GetService(&quot;Players&quot;) local player = Players.LocalPlayer local PlayerGui = player.PlayerGui local root = script.Parent.Parent.Parent local Types = require(root.Types) local e2en: Types.e2enClient = require(root) :: any local ShopController = e2en.CreateController({ Name = &quot;ShopController&quot;, Dependencies = { &quot;NotificationController&quot; }, }) -- UI references local ShopGui = PlayerGui:WaitForChild(&quot;Shop&quot;) :: ScreenGui local MainFrame = ShopGui:WaitForChild(&quot;Main&quot;) :: Frame local ItemsContainer = MainFrame:WaitForChild(&quot;Items&quot;) :: ScrollingFrame local CloseButton = MainFrame:WaitForChild(&quot;Close&quot;) :: TextButton local CoinsLabel = MainFrame:WaitForChild(&quot;Coins&quot;) :: TextLabel -- Template local ItemTemplate = ItemsContainer:WaitForChild(&quot;Template&quot;) :: Frame function ShopController:Init() self._notifications = e2en.GetController(&quot;NotificationController&quot;) self._shopService = nil -- Set in Start CloseButton.Activated:Connect(function() self:Hide() end) end function ShopController:Start() self._shopService = e2en.GetService(&quot;ShopService&quot;) -- Update coins display self._shopService.Coins:Observe(function(coins) CoinsLabel.Text = tostring(coins) end) -- Populate items self:PopulateItems() end function ShopController:PopulateItems() local items = self._shopService:GetItems() for _, item in items do local itemFrame = ItemTemplate:Clone() itemFrame.Name = item.id itemFrame.ItemName.Text = item.name itemFrame.Price.Text = tostring(item.price) itemFrame.Visible = true itemFrame.BuyButton.Activated:Connect(function() self:TryPurchase(item.id) end) itemFrame.Parent = ItemsContainer end end function ShopController:TryPurchase(itemId: string) local success = self._shopService:Purchase(itemId) if success then self._notifications:Show(&quot;Purchase successful!&quot;) else self._notifications:Show(&quot;Not enough coins!&quot;) end end function ShopController:Show() ShopGui.Enabled = true end function ShopController:Hide() ShopGui.Enabled = false end return ShopController  ","version":"Next","tagName":"h2"},{"title":"Lifecycle","type":0,"sectionRef":"#","url":"/e2en/docs/lifecycle","content":"","keywords":"","version":"Next"},{"title":"Server Lifecycle​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#server-lifecycle","content":" ","version":"Next","tagName":"h2"},{"title":"Player Added​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#player-added","content":" Called when a player joins. Also fires retroactively for players already in the game.  e2en.OnPlayerAdded(function(player: Player, trove: Trove) print(player.Name, &quot;joined&quot;) -- Load their data local data = loadData(player) -- Add things to the trove for auto-cleanup trove:Add(createPlayerState(player)) trove:Connect(player.Chatted, function(message) print(player.Name, &quot;said:&quot;, message) end) end)   The trove automatically cleans up when the player leaves—no manual disconnection needed.  ","version":"Next","tagName":"h3"},{"title":"Player Removing​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#player-removing","content":" Called when a player is about to leave. Use this for saving data.  e2en.OnPlayerRemoving(function(player: Player) print(player.Name, &quot;leaving&quot;) saveData(player) end)   ","version":"Next","tagName":"h3"},{"title":"Character Added​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#character-added","content":" Called when a character spawns. Also fires retroactively for existing characters.  e2en.OnCharacterAdded(function(player: Player, character: Model, trove: Trove) print(player.Name, &quot;spawned&quot;) local humanoid = character:WaitForChild(&quot;Humanoid&quot;) :: Humanoid -- Auto-cleanup when character dies/respawns trove:Connect(humanoid.Died, function() print(player.Name, &quot;died&quot;) end) trove:Connect(humanoid.Running, function(speed) if speed &gt; 0 then print(player.Name, &quot;is running&quot;) end end) end)   ","version":"Next","tagName":"h3"},{"title":"Character Removing​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#character-removing","content":" Called when a character is about to be removed.  e2en.OnCharacterRemoving(function(player: Player, character: Model) print(player.Name, &quot;character removing&quot;) end)   ","version":"Next","tagName":"h3"},{"title":"Getting Troves Manually​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#getting-troves-manually","content":" local playerTrove = e2en.GetPlayerTrove(player) local characterTrove = e2en.GetCharacterTrove(player) if playerTrove then playerTrove:Add(someCleanupTarget) end   ","version":"Next","tagName":"h3"},{"title":"Client Lifecycle​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#client-lifecycle","content":" ","version":"Next","tagName":"h2"},{"title":"Character Added​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#character-added-1","content":" e2en.OnCharacterAdded(function(character: Model, trove: Trove) print(&quot;Spawned&quot;) local humanoid = character:WaitForChild(&quot;Humanoid&quot;) :: Humanoid trove:Connect(humanoid.Died, function() print(&quot;Died&quot;) end) trove:Connect(humanoid.HealthChanged, function(health) updateHealthBar(health) end) end)   ","version":"Next","tagName":"h3"},{"title":"Character Removing​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#character-removing-1","content":" e2en.OnCharacterRemoving(function(character: Model) print(&quot;Character removing&quot;) end)   ","version":"Next","tagName":"h3"},{"title":"Getting Current Character​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#getting-current-character","content":" -- Returns nil if no character exists local character = e2en.GetCharacter() -- Get the character's trove (nil if no character) local trove = e2en.GetCharacterTrove()   ","version":"Next","tagName":"h3"},{"title":"Player Reference​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#player-reference","content":" local player = e2en.Player print(&quot;I am&quot;, player.Name)   ","version":"Next","tagName":"h3"},{"title":"The Trove Pattern​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#the-trove-pattern","content":" Troves manage cleanup automatically. When a trove is cleaned (player leaves, character dies), everything added to it is destroyed/disconnected.  ","version":"Next","tagName":"h2"},{"title":"Adding Objects​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#adding-objects","content":" e2en.OnPlayerAdded(function(player, trove) -- Instances are destroyed local folder = Instance.new(&quot;Folder&quot;) folder.Name = player.Name trove:Add(folder) folder.Parent = workspace -- Connections are disconnected trove:Connect(player.Chatted, function(msg) print(msg) end) -- Tables with Destroy method local state = { Destroy = function() print(&quot;cleaned up&quot;) end } trove:Add(state) -- Custom cleanup method local resource = createResource() trove:Add(resource, &quot;Release&quot;) -- calls resource:Release() end)   ","version":"Next","tagName":"h3"},{"title":"Nested Troves​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#nested-troves","content":" Create sub-troves for grouped cleanup:  e2en.OnCharacterAdded(function(player, character, trove) -- Combat-related stuff local combatTrove = Trove.new() trove:Add(combatTrove) combatTrove:Connect(...) combatTrove:Add(...) -- Clear combat stuff without clearing everything combatTrove:Clean() end)   ","version":"Next","tagName":"h3"},{"title":"Lifecycle Timing​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#lifecycle-timing","content":"   ","version":"Next","tagName":"h2"},{"title":"Common Patterns​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#common-patterns","content":" ","version":"Next","tagName":"h2"},{"title":"Per-Player State​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#per-player-state","content":" local playerStates = {} e2en.OnPlayerAdded(function(player, trove) playerStates[player] = { score = 0, inventory = {}, } end) e2en.OnPlayerRemoving(function(player) playerStates[player] = nil end)   ","version":"Next","tagName":"h3"},{"title":"Character Components​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#character-components","content":" e2en.OnCharacterAdded(function(player, character, trove) -- Add a highlight that auto-removes on death local highlight = Instance.new(&quot;Highlight&quot;) highlight.FillColor = Color3.new(1, 0, 0) trove:Add(highlight) highlight.Parent = character -- Track running state local humanoid = character:WaitForChild(&quot;Humanoid&quot;) :: Humanoid local isRunning = false trove:Connect(humanoid.Running, function(speed) isRunning = speed &gt; 0 end) end)   ","version":"Next","tagName":"h3"},{"title":"Waiting for Character​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#waiting-for-character","content":" function MyService:DoSomethingWithCharacter(player: Player) local character = player.Character if not character then character = player.CharacterAdded:Wait() end -- Now we have a character end   ","version":"Next","tagName":"h3"},{"title":"Client: Waiting for Server​","type":1,"pageTitle":"Lifecycle","url":"/e2en/docs/lifecycle#client-waiting-for-server","content":" function MyController:Start() -- Wait for framework to be fully ready e2en.OnStart() -- Now safe to access services local GameService = e2en.GetService(&quot;GameService&quot;) end  ","version":"Next","tagName":"h3"},{"title":"Type Safety","type":0,"sectionRef":"#","url":"/e2en/docs/type-safety","content":"","keywords":"","version":"Next"},{"title":"The :: any Pattern​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#the--any-pattern","content":" You'll see this pattern when requiring the framework:  local e2en: Types.e2enServer = require(root) :: any   The framework returns different modules at runtime depending on context (server vs client), which Luau's static analysis can't resolve. The :: any cast bypasses the type error at this boundary, and the explicit annotation (: Types.e2enServer) restores intellisense and type checking for all subsequent code.  ","version":"Next","tagName":"h2"},{"title":"Setting Up Types​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#setting-up-types","content":" ","version":"Next","tagName":"h2"},{"title":"Server Code​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#server-code","content":" local root = script.Parent.Parent.Parent local Types = require(root.Types) local e2en: Types.e2enServer = require(root) :: any   ","version":"Next","tagName":"h3"},{"title":"Client Code​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#client-code","content":" local root = script.Parent.Parent.Parent local Types = require(root.Types) local e2en: Types.e2enClient = require(root) :: any   ","version":"Next","tagName":"h3"},{"title":"Available Types​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#available-types","content":" Import types from the Types module:  local Types = require(root.Types) -- Core types export type Service = Types.Service export type Controller = Types.Controller export type ServiceDefinition = Types.ServiceDefinition export type ControllerDefinition = Types.ControllerDefinition -- Communication types export type RemoteSignal&lt;T...&gt; = Types.RemoteSignal&lt;T...&gt; export type RemoteProperty&lt;T&gt; = Types.RemoteProperty&lt;T&gt; export type ClientRemoteSignal&lt;T...&gt; = Types.ClientRemoteSignal&lt;T...&gt; export type ClientRemoteProperty&lt;T&gt; = Types.ClientRemoteProperty&lt;T&gt; -- Utility types export type Trove = Types.Trove export type Signal&lt;T...&gt; = Types.Signal&lt;T...&gt; export type Connection = Types.Connection   ","version":"Next","tagName":"h2"},{"title":"Type Checking Commands​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#type-checking-commands","content":" Run type checking after every .luau change:  luau-lsp analyze \\ --sourcemap=sourcemap.json \\ --defs=.luau-types/globalTypes.d.luau \\ --flag:LuauSolverV2=false \\ --ignore=&quot;**/Libraries/**&quot; \\ --ignore=&quot;**/Iris/**&quot; \\ e2en/src src   Generate the sourcemap first:  rojo sourcemap default.project.json --output sourcemap.json   ","version":"Next","tagName":"h2"},{"title":"Strict Mode​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#strict-mode","content":" e2en uses strict mode via .luaurc, not --!strict comments. Your .luaurc should include:  { &quot;languageMode&quot;: &quot;strict&quot; }   ","version":"Next","tagName":"h2"},{"title":"Validating Client Input​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#validating-client-input","content":" When handling client input, use any (not unknown) and validate:  function MyService.Client:DoSomething(player: Player, value: any): boolean -- Validate type if typeof(value) ~= &quot;string&quot; then return false end -- Now value is narrowed to string return self.Server:ProcessString(player, value) end   ","version":"Next","tagName":"h2"},{"title":"Type Narrowing​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#type-narrowing","content":" Use guard clauses for type narrowing:  -- Good: Guard clause narrows type function process(data: any) if typeof(data) ~= &quot;table&quot; then return end -- data is now table if typeof(data.name) ~= &quot;string&quot; then return end -- data.name is now string end -- Avoid: Conditional access doesn't narrow function process(data: any) if data and data.name then -- data.name is still any end end   ","version":"Next","tagName":"h3"},{"title":"Generic Services​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#generic-services","content":" Type your custom service methods:  local InventoryService = e2en.CreateService({ Name = &quot;InventoryService&quot;, Client = {}, _items = {} :: { [Player]: { string } }, }) function InventoryService:GetItems(player: Player): { string } return self._items[player] or {} end function InventoryService:AddItem(player: Player, itemId: string): boolean local items = self._items[player] if not items then items = {} self._items[player] = items end table.insert(items, itemId) return true end   ","version":"Next","tagName":"h2"},{"title":"Typed Remote Properties​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#typed-remote-properties","content":" type PlayerData = { coins: number, level: number, inventory: { string }, } local DataService = e2en.CreateService({ Name = &quot;DataService&quot;, Client = { PlayerData = e2en.CreateProperty({} :: PlayerData), }, }) -- Type is inferred self.Client.PlayerData:SetFor(player, { coins = 100, level = 1, inventory = {}, })   ","version":"Next","tagName":"h2"},{"title":"Typed Signals​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#typed-signals","content":" type DamageEvent = { amount: number, source: string, critical: boolean, } local CombatService = e2en.CreateService({ Name = &quot;CombatService&quot;, Client = { DamageDealt = e2en.CreateSignal(), -- RemoteSignal&lt;DamageEvent&gt; }, }) -- Fire with typed data self.Client.DamageDealt:Fire(player, { amount = 25, source = &quot;Enemy&quot;, critical = false, } :: DamageEvent)   ","version":"Next","tagName":"h2"},{"title":"Common Type Patterns​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#common-type-patterns","content":" ","version":"Next","tagName":"h2"},{"title":"Optional Values​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#optional-values","content":" function findPlayer(name: string): Player? for _, player in Players:GetPlayers() do if player.Name == name then return player end end return nil end local player = findPlayer(&quot;Bob&quot;) if player then -- player is Player (not Player?) end   ","version":"Next","tagName":"h3"},{"title":"Callbacks with Trove​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#callbacks-with-trove","content":" e2en.OnCharacterAdded(function(player: Player, character: Model, trove: Trove) local humanoid = character:WaitForChild(&quot;Humanoid&quot;) :: Humanoid trove:Connect(humanoid.Died, function() -- Type-safe callback end) end)   ","version":"Next","tagName":"h3"},{"title":"Type Assertions​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#type-assertions","content":" When you know more than the type system:  local part = workspace:FindFirstChild(&quot;SpawnPoint&quot;) assert(part, &quot;SpawnPoint not found&quot;) -- part is Instance, but we know it's a Part local spawnPart = part :: Part print(spawnPart.Position)   ","version":"Next","tagName":"h3"},{"title":"Excluded from Strict Checking​","type":1,"pageTitle":"Type Safety","url":"/e2en/docs/type-safety#excluded-from-strict-checking","content":" Some folders are excluded from strict type checking:  Libraries/ - Third-party codeIris/ - UI libraryShapecastHitbox/ - External moduleClientLoader.client.luau - Bootstrap script  Configure exclusions in your type check command with --ignore. ","version":"Next","tagName":"h2"},{"title":"Middleware","type":0,"sectionRef":"#","url":"/e2en/docs/middleware","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#configuration","content":" Pass middleware to e2en.Run():  e2en.Run({ Middleware = { Inbound = { validateMiddleware, logMiddleware }, Outbound = { serializeMiddleware }, } })   ","version":"Next","tagName":"h2"},{"title":"Inbound Middleware​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#inbound-middleware","content":" Inbound middleware intercepts client → server remote function calls.  ","version":"Next","tagName":"h2"},{"title":"Signature​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#signature","content":" function(player: Player, serviceName: string, methodName: string, args: {any}): (boolean, {any})   Parameter\tDescriptionplayer\tThe player making the request serviceName\tName of the service being called methodName\tName of the method being called args\tArguments passed by the client  Return\tDescriptionboolean\ttrue to continue, false to drop the request {any}\tThe (possibly modified) arguments to pass forward  ","version":"Next","tagName":"h3"},{"title":"Example: Logging​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#example-logging","content":" local function logMiddleware(player, serviceName, methodName, args) print(string.format( &quot;[%s] %s called %s:%s&quot;, os.date(&quot;%H:%M:%S&quot;), player.Name, serviceName, methodName )) return true, args end   ","version":"Next","tagName":"h3"},{"title":"Example: Rate Limiting​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#example-rate-limiting","content":" local rateLimits = {} local RATE_LIMIT = 10 -- calls per second local function rateLimitMiddleware(player, serviceName, methodName, args) local key = player.UserId .. &quot;:&quot; .. serviceName .. &quot;:&quot; .. methodName local now = os.clock() local history = rateLimits[key] or {} -- Remove old entries local newHistory = {} for _, timestamp in history do if now - timestamp &lt; 1 then table.insert(newHistory, timestamp) end end if #newHistory &gt;= RATE_LIMIT then warn(player.Name, &quot;rate limited on&quot;, serviceName .. &quot;:&quot; .. methodName) return false, {} end table.insert(newHistory, now) rateLimits[key] = newHistory return true, args end   ","version":"Next","tagName":"h3"},{"title":"Example: Validation​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#example-validation","content":" local function validateMiddleware(player, serviceName, methodName, args) -- Check if player is still valid if not player.Parent then return false, {} end -- Check if player is banned if bannedPlayers[player.UserId] then return false, {} end return true, args end   ","version":"Next","tagName":"h3"},{"title":"Outbound Middleware​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#outbound-middleware","content":" Outbound middleware intercepts server → client signals and property updates.  ","version":"Next","tagName":"h2"},{"title":"Signature​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#signature-1","content":" function(player: Player?, serviceName: string, signalName: string, args: {any}): (boolean, {any})   Parameter\tDescriptionplayer\tTarget player (nil for FireAll) serviceName\tName of the service signalName\tName of the signal or property args\tData being sent  ","version":"Next","tagName":"h3"},{"title":"Example: Serialization​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#example-serialization","content":" local function serializeMiddleware(player, serviceName, signalName, args) -- Convert Vector3 to table for network efficiency local processed = {} for i, arg in args do if typeof(arg) == &quot;Vector3&quot; then processed[i] = { x = arg.X, y = arg.Y, z = arg.Z } else processed[i] = arg end end return true, processed end   ","version":"Next","tagName":"h3"},{"title":"Example: Filtering Sensitive Data​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#example-filtering-sensitive-data","content":" local function filterMiddleware(player, serviceName, signalName, args) -- Don't send admin data to non-admins if signalName == &quot;AdminData&quot; then if not player or not player:GetAttribute(&quot;IsAdmin&quot;) then return false, {} end end return true, args end   ","version":"Next","tagName":"h3"},{"title":"Middleware Chain​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#middleware-chain","content":" Middleware runs in array order. Each middleware receives the output of the previous one.  Middleware = { Inbound = { first, second, third }, }   Request arrives │ ▼ ┌─────────┐ │ first │ ── returns true, modifiedArgs1 └─────────┘ │ ▼ ┌─────────┐ │ second │ ── returns true, modifiedArgs2 └─────────┘ │ ▼ ┌─────────┐ │ third │ ── returns true, finalArgs └─────────┘ │ ▼ Handler called with finalArgs   If any middleware returns false, the chain stops and the request is dropped:  Request arrives │ ▼ ┌─────────┐ │ first │ ── returns true, args └─────────┘ │ ▼ ┌─────────┐ │ second │ ── returns false, {} └─────────┘ │ ▼ Request dropped (handler never called)   ","version":"Next","tagName":"h2"},{"title":"Complete Example​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#complete-example","content":" -- Loader.server.luau local ServerScriptService = game:GetService(&quot;ServerScriptService&quot;) local Types = require(ServerScriptService.e2en.Types) local e2en: Types.e2enServer = require(ServerScriptService.e2en) :: any -- Rate limiting state local callHistory = {} local function rateLimitMiddleware(player, serviceName, methodName, args) local key = tostring(player.UserId) local now = os.clock() callHistory[key] = callHistory[key] or {} local history = callHistory[key] -- Clean old entries for i = #history, 1, -1 do if now - history[i] &gt; 1 then table.remove(history, i) end end -- Check limit if #history &gt;= 30 then return false, {} end table.insert(history, now) return true, args end local function logMiddleware(player, serviceName, methodName, args) print(string.format( &quot;[RPC] %s -&gt; %s:%s (%d args)&quot;, player.Name, serviceName, methodName, #args )) return true, args end local function sanitizeMiddleware(player, serviceName, signalName, args) -- Remove internal fields before sending to clients local cleaned = {} for i, arg in args do if type(arg) == &quot;table&quot; then local copy = table.clone(arg) copy._internal = nil copy._debug = nil cleaned[i] = copy else cleaned[i] = arg end end return true, cleaned end e2en.Run({ Middleware = { Inbound = { rateLimitMiddleware, logMiddleware, }, Outbound = { sanitizeMiddleware, }, } })   ","version":"Next","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Middleware","url":"/e2en/docs/middleware#best-practices","content":" Keep middleware fast - It runs on every network callReturn early - Check failure conditions firstDon't yield - Middleware should be synchronousClean up state - For rate limiters, periodically remove old entriesLog sparingly - Excessive logging impacts performanceOrder matters - Put validation before logging to avoid logging invalid requests ","version":"Next","tagName":"h2"},{"title":"Services","type":0,"sectionRef":"#","url":"/e2en/docs/services","content":"","keywords":"","version":"Next"},{"title":"Creating a Service​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#creating-a-service","content":" local root = script.Parent.Parent.Parent local Types = require(root.Types) local e2en: Types.e2enServer = require(root) :: any local InventoryService = e2en.CreateService({ Name = &quot;InventoryService&quot;, }) function InventoryService:Init() -- Setup code end function InventoryService:Start() -- Game loop code end return InventoryService   ","version":"Next","tagName":"h2"},{"title":"Service Definition​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#service-definition","content":" The table passed to CreateService can include:  Field\tType\tDescriptionName\tstring\tRequired. Unique identifier for the service. Client\ttable\tMethods, signals, and properties exposed to clients. Dependencies\t{string}\tServices that must initialize before this one. Init\tfunction\tCalled synchronously during startup. Start\tfunction\tCalled asynchronously after all services initialize. custom\tany\tAny other fields become part of the service table.  ","version":"Next","tagName":"h2"},{"title":"The Client Table​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#the-client-table","content":" The Client table defines what clients can access. It supports three types of entries:  ","version":"Next","tagName":"h2"},{"title":"Functions (Remote Methods)​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#functions-remote-methods","content":" Functions in the Client table become callable from clients:  local ShopService = e2en.CreateService({ Name = &quot;ShopService&quot;, Client = { PurchaseItem = function(self, player: Player, itemId: string): boolean -- 'self' is the Client table -- 'player' is automatically injected if not hasEnoughGold(player, itemId) then return false end giveItem(player, itemId) return true end, }, })   On the client:  local ShopService = e2en.GetService(&quot;ShopService&quot;) local success = ShopService:PurchaseItem(&quot;sword_01&quot;)   Validate Client Input Never trust data from clients. Always validate: PurchaseItem = function(self, player: Player, itemId: any): boolean if typeof(itemId) ~= &quot;string&quot; then return false end -- Now safe to use end   ","version":"Next","tagName":"h3"},{"title":"Signals (Remote Events)​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#signals-remote-events","content":" Use CreateSignal() for events you want to fire to clients:  local CombatService = e2en.CreateService({ Name = &quot;CombatService&quot;, Client = { DamageDealt = e2en.CreateSignal(), PlayerKilled = e2en.CreateSignal(), }, }) -- Fire to a specific player self.Client.DamageDealt:Fire(player, { amount = 25, source = &quot;Enemy&quot; }) -- Fire to all players self.Client.PlayerKilled:FireAll({ victim = player.Name, killer = enemyName })   Clients can also fire signals back to the server:  -- Server self.Client.DamageDealt:Connect(function(player, data) -- Handle client-sent event -- Always validate! end)   For high-frequency, loss-tolerant data (like position updates), use unreliable signals:  Client = { PositionUpdate = e2en.CreateUnreliableSignal(), }   ","version":"Next","tagName":"h3"},{"title":"Properties (Replicated State)​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#properties-replicated-state","content":" Use CreateProperty() for state that should sync to clients:  local GameService = e2en.CreateService({ Name = &quot;GameService&quot;, Client = { GamePhase = e2en.CreateProperty(&quot;Waiting&quot;), PlayerScores = e2en.CreateProperty({}), }, }) -- Set for all players self.Client.GamePhase:Set(&quot;Playing&quot;) -- Set for a specific player self.Client.PlayerScores:SetFor(player, { kills = 5, deaths = 2 })   ","version":"Next","tagName":"h3"},{"title":"Accessing Other Services​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#accessing-other-services","content":" Use GetService() to access other services:  function InventoryService:Start() local DataService = e2en.GetService(&quot;DataService&quot;) local PlayerService = e2en.GetService(&quot;PlayerService&quot;) end   If you need a service during Init(), declare it as a dependency:  local InventoryService = e2en.CreateService({ Name = &quot;InventoryService&quot;, Dependencies = { &quot;DataService&quot; }, }) function InventoryService:Init() -- DataService is guaranteed to be initialized self._dataService = e2en.GetService(&quot;DataService&quot;) end   ","version":"Next","tagName":"h2"},{"title":"Custom Properties and Methods​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#custom-properties-and-methods","content":" Add any properties or methods you need:  local MatchService = e2en.CreateService({ Name = &quot;MatchService&quot;, -- Custom properties _matches = {}, _config = { maxPlayersPerMatch = 10, matchDuration = 300, }, }) -- Custom methods function MatchService:CreateMatch(players: {Player}) local match = { id = HttpService:GenerateGUID(), players = players, startTime = os.clock(), } self._matches[match.id] = match return match end function MatchService:EndMatch(matchId: string) local match = self._matches[matchId] if match then -- Cleanup logic self._matches[matchId] = nil end end   ","version":"Next","tagName":"h2"},{"title":"Loading Services​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#loading-services","content":" ","version":"Next","tagName":"h2"},{"title":"Automatic (Recommended)​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#automatic-recommended","content":" When you call e2en.Run(), it automatically loads all Services from the Systems/ folder:  Systems/ ├── Combat/ │ └── Service.luau ← Loaded automatically ├── Inventory/ │ └── Service.luau ← Loaded automatically   ","version":"Next","tagName":"h3"},{"title":"Manual Loading​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#manual-loading","content":" For more control, use the loading methods:  -- Load direct children e2en.AddServices(someFolder) -- Load all descendants e2en.AddServicesDeep(someFolder) -- Load Service.luau from immediate child folders e2en.AddSystems(someFolder) -- Load Service.luau from all descendant folders e2en.AddSystemsDeep(someFolder)   ","version":"Next","tagName":"h3"},{"title":"Example: Complete Service​","type":1,"pageTitle":"Services","url":"/e2en/docs/services#example-complete-service","content":" local root = script.Parent.Parent.Parent local Types = require(root.Types) local e2en: Types.e2enServer = require(root) :: any local CurrencyService = e2en.CreateService({ Name = &quot;CurrencyService&quot;, Dependencies = { &quot;DataService&quot; }, Client = { CoinsChanged = e2en.CreateSignal(), Coins = e2en.CreateProperty(0), GetCoins = function(self, player: Player): number return self.Server:GetCoins(player) end, }, _playerCoins = {}, }) function CurrencyService:Init() self._dataService = e2en.GetService(&quot;DataService&quot;) end function CurrencyService:Start() e2en.OnPlayerAdded(function(player, trove) local data = self._dataService:GetData(player) self._playerCoins[player] = data.coins or 0 self.Client.Coins:SetFor(player, self._playerCoins[player]) end) e2en.OnPlayerRemoving(function(player) self._playerCoins[player] = nil end) end function CurrencyService:GetCoins(player: Player): number return self._playerCoins[player] or 0 end function CurrencyService:AddCoins(player: Player, amount: number) local current = self:GetCoins(player) local newAmount = current + amount self._playerCoins[player] = newAmount self.Client.Coins:SetFor(player, newAmount) self.Client.CoinsChanged:Fire(player, { old = current, new = newAmount }) end return CurrencyService  ","version":"Next","tagName":"h2"},{"title":"Utilities","type":0,"sectionRef":"#","url":"/e2en/docs/utilities","content":"","keywords":"","version":"Next"},{"title":"Iteration​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#iteration","content":" ","version":"Next","tagName":"h2"},{"title":"ForEach​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#foreach","content":" Synchronous iteration over a table.  e2en.ForEach(players, function(player, index) print(index, player.Name) end) -- With performance tracking e2en.ForEach(items, callback, &quot;ProcessInventory&quot;)   ","version":"Next","tagName":"h3"},{"title":"ForEachAsync​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#foreachasync","content":" Spawns each callback in a separate thread.  e2en.ForEachAsync(players, function(player, index) -- Each runs in parallel loadPlayerData(player) end)   ","version":"Next","tagName":"h3"},{"title":"Map​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#map","content":" Transform values into a new table.  local names = e2en.Map(players, function(player) return player.Name end) -- { &quot;Player1&quot;, &quot;Player2&quot;, ... } local doubled = e2en.Map({ 1, 2, 3 }, function(n) return n * 2 end) -- { 2, 4, 6 }   ","version":"Next","tagName":"h3"},{"title":"Filter​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#filter","content":" Select values matching a predicate. Returns an array.  local adults = e2en.Filter(users, function(user) return user.age &gt;= 18 end) local positives = e2en.Filter({ -1, 2, -3, 4 }, function(n) return n &gt; 0 end) -- { 2, 4 }   ","version":"Next","tagName":"h3"},{"title":"Find​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#find","content":" Get the first value matching a predicate.  local admin = e2en.Find(players, function(player) return player:GetAttribute(&quot;IsAdmin&quot;) end) if admin then print(&quot;Found admin:&quot;, admin.Name) end   ","version":"Next","tagName":"h3"},{"title":"Reduce​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#reduce","content":" Aggregate values into a single result.  local total = e2en.Reduce(prices, function(sum, price) return sum + price end, 0) local concatenated = e2en.Reduce(words, function(result, word) return result .. &quot; &quot; .. word end, &quot;&quot;)   ","version":"Next","tagName":"h3"},{"title":"Every​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#every","content":" Check if all values match a predicate.  local allReady = e2en.Every(players, function(player) return player:GetAttribute(&quot;Ready&quot;) end) if allReady then startGame() end   ","version":"Next","tagName":"h3"},{"title":"Some​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#some","content":" Check if any value matches a predicate.  local hasEnemy = e2en.Some(entities, function(entity) return entity.Type == &quot;Enemy&quot; end)   ","version":"Next","tagName":"h3"},{"title":"Table Operations​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#table-operations","content":" ","version":"Next","tagName":"h2"},{"title":"Reverse​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#reverse","content":" Reverse array order.  local reversed = e2en.Reverse({ 1, 2, 3 }) -- { 3, 2, 1 }   ","version":"Next","tagName":"h3"},{"title":"Shuffle​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#shuffle","content":" Randomize array order.  local shuffled = e2en.Shuffle({ 1, 2, 3, 4, 5 }) -- Random order each time   ","version":"Next","tagName":"h3"},{"title":"Copy​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#copy","content":" Clone a table (shallow or deep).  local shallow = e2en.Copy(original) local deep = e2en.Copy(original, true)   ","version":"Next","tagName":"h3"},{"title":"Keys​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#keys","content":" Get all keys from a table.  local keys = e2en.Keys({ a = 1, b = 2, c = 3 }) -- { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }   ","version":"Next","tagName":"h3"},{"title":"Values​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#values","content":" Get all values from a table.  local values = e2en.Values({ a = 1, b = 2, c = 3 }) -- { 1, 2, 3 }   ","version":"Next","tagName":"h3"},{"title":"Count​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#count","content":" Count entries in a table (works for dictionaries).  local count = e2en.Count({ a = 1, b = 2, c = 3 }) -- 3   ","version":"Next","tagName":"h3"},{"title":"Flat​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#flat","content":" Flatten nested arrays.  local flat = e2en.Flat({ { 1, 2 }, { 3, { 4 } } }) -- { 1, 2, 3, { 4 } } local deepFlat = e2en.Flat({ { 1, { 2, { 3 } } } }, 2) -- { 1, 2, { 3 } }   ","version":"Next","tagName":"h3"},{"title":"Timing​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#timing","content":" ","version":"Next","tagName":"h2"},{"title":"Step​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#step","content":" Run a function every frame.  -- Heartbeat (server and client) local connection = e2en.Step(&quot;UpdatePositions&quot;, function(dt) updateAllPositions(dt) end) -- RenderStepped (client only) local connection = e2en.Step(&quot;UpdateCamera&quot;, function(dt) updateCamera(dt) end, true)   ","version":"Next","tagName":"h3"},{"title":"StopStep​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#stopstep","content":" Stop a running step.  e2en.StopStep(&quot;UpdatePositions&quot;)   ","version":"Next","tagName":"h3"},{"title":"GetActiveSteps​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#getactivesteps","content":" Get names of all running steps.  local steps = e2en.GetActiveSteps() -- { &quot;UpdatePositions&quot;, &quot;UpdateCamera&quot; }   ","version":"Next","tagName":"h3"},{"title":"Defer​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#defer","content":" Run next frame.  e2en.Defer(function() print(&quot;Runs next frame&quot;) end) -- With arguments e2en.Defer(function(a, b) print(a + b) end, 1, 2)   ","version":"Next","tagName":"h3"},{"title":"Delay​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#delay","content":" Run after a duration.  e2en.Delay(2, function() print(&quot;2 seconds later&quot;) end) -- With arguments e2en.Delay(1, function(message) print(message) end, &quot;Hello!&quot;)   ","version":"Next","tagName":"h3"},{"title":"WaitFor​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#waitfor","content":" Poll until a condition is met.  local target = e2en.WaitFor(function() return workspace:FindFirstChild(&quot;Target&quot;) end, 10, 0.1) -- timeout, interval if target then print(&quot;Found target!&quot;) else print(&quot;Timed out&quot;) end   ","version":"Next","tagName":"h3"},{"title":"Performance Tracking​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#performance-tracking","content":" Track execution time of utility functions.  ","version":"Next","tagName":"h2"},{"title":"Enable Tracking​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#enable-tracking","content":" e2en.EnablePerformanceTracking(true)   ","version":"Next","tagName":"h3"},{"title":"Automatic Tracking​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#automatic-tracking","content":" All iteration functions support a tracking name:  e2en.ForEach(items, callback, &quot;ProcessItems&quot;) e2en.Map(data, transform, &quot;TransformData&quot;)   Steps are automatically tracked:  e2en.Step(&quot;GameLoop&quot;, function(dt) -- Tracked as &quot;Step:GameLoop&quot; end)   ","version":"Next","tagName":"h3"},{"title":"Get Performance Data​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#get-performance-data","content":" local data = e2en.GetPerformanceData() --[[ { [&quot;ProcessItems&quot;] = { calls = 100, totalTime = 0.5, avgTime = 0.005, peakTime = 0.02, lastCall = 12345.67, }, [&quot;Step:GameLoop&quot;] = { ... }, } ]]   ","version":"Next","tagName":"h3"},{"title":"Print Report​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#print-report","content":" e2en.PrintPerformanceReport() -- Output: -- === Performance Report === -- [Step:GameLoop] calls: 1000 | total: 50.0000ms | avg: 0.0500ms | peak: 0.2000ms -- [ProcessItems] calls: 100 | total: 5.0000ms | avg: 0.0500ms | peak: 0.1000ms -- ==========================   ","version":"Next","tagName":"h3"},{"title":"Clear Data​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#clear-data","content":" e2en.ClearPerformanceData()   ","version":"Next","tagName":"h3"},{"title":"Estimate Memory Usage​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#estimate-memory-usage","content":" local bytes = e2en.EstimateMemoryUsage(someTable) print(&quot;Estimated size:&quot;, bytes, &quot;bytes&quot;)   ","version":"Next","tagName":"h3"},{"title":"Practical Examples​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#practical-examples","content":" ","version":"Next","tagName":"h2"},{"title":"Filtering Active Players​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#filtering-active-players","content":" local activePlayers = e2en.Filter(Players:GetPlayers(), function(player) return player.Character and player.Character:FindFirstChild(&quot;Humanoid&quot;) end)   ","version":"Next","tagName":"h3"},{"title":"Calculating Total Score​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#calculating-total-score","content":" local totalScore = e2en.Reduce(players, function(total, player) return total + (playerScores[player] or 0) end, 0)   ","version":"Next","tagName":"h3"},{"title":"Finding Nearest Enemy​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#finding-nearest-enemy","content":" local nearest = e2en.Reduce(enemies, function(closest, enemy) local distance = (enemy.Position - myPosition).Magnitude if not closest or distance &lt; closest.distance then return { enemy = enemy, distance = distance } end return closest end, nil) if nearest then print(&quot;Nearest enemy:&quot;, nearest.enemy.Name) end   ","version":"Next","tagName":"h3"},{"title":"Spawning Items with Delay​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#spawning-items-with-delay","content":" e2en.ForEach(spawnPoints, function(point, index) e2en.Delay(index * 0.5, function() spawnItemAt(point.Position) end) end)   ","version":"Next","tagName":"h3"},{"title":"Polling for Game State​","type":1,"pageTitle":"Utilities","url":"/e2en/docs/utilities#polling-for-game-state","content":" local gameStarted = e2en.WaitFor(function() local GameService = e2en.GetService(&quot;GameService&quot;) local phase = GameService.GamePhase:Get() return phase == &quot;Playing&quot; and true or nil end, 60) if gameStarted then print(&quot;Game started!&quot;) else print(&quot;Timed out waiting for game&quot;) end  ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}